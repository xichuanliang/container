<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/container.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/container.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/container.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/container.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/container.github.io/css/main.css">


<link rel="stylesheet" href="/container.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xichuanliang.github.io","root":"/container.github.io/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://xichuanliang.github.io/container.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xichuanliang.github.io/container.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/container.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/container.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/container.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xichuanliang.github.io/container.github.io/2024/03/03/ping-service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/container.github.io/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/container.github.io/2024/03/03/ping-service/" class="post-title-link" itemprop="url">ping service?</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-03 16:09:19" itemprop="dateCreated datePublished" datetime="2024-03-03T16:09:19+08:00">2024-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-08 20:54:35" itemprop="dateModified" datetime="2024-03-08T20:54:35+08:00">2024-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="node能否ping通service的ClusterIP？"><a href="#node能否ping通service的ClusterIP？" class="headerlink" title="node能否ping通service的ClusterIP？"></a>node能否ping通service的ClusterIP？</h2><ul>
<li>现象：</li>
</ul>
<p>​        在1.21版本的k8s集群中，在node节点能够ping通service的ClusterIP，但是在1.27版本的k8s集群中，在node节点无法ping通service的ClusterIP。</p>
<p><img src="/container.github.io/images/image-20240302225740880.png" alt="image-20240302225740880"></p>
<p><img src="/container.github.io/images/image-20240302225842963.png" alt="image-20240302225842963"></p>
<ul>
<li><p>观察：</p>
<ul>
<li>ping IP，报的错误是Destination Port Unreachable。</li>
</ul>
</li>
<li><p>上网查询可能的原因以及解决方案：</p>
<ul>
<li>原因：在k8s中，如果kube-proxy使用的是iptables，service会出现ping不同ClusterIP。在ipvs的模式下，是能够ping通ClusterIP。</li>
<li>验证结果：在两台虚拟机中，同时验证是否开启了ipvs，以及kube-proxy的模式是什么。发现，两台虚拟机都开启了ipvs，并且都是ipvs的模式。</li>
</ul>
<p><img src="/container.github.io/images/image-20240303151256063.png" alt="image-20240303151256063"></p>
<p>​																configmap for kube-proxy</p>
<p><img src="/container.github.io/images/image-20240303151423352.png" alt="image-20240303151423352"></p>
<p>​																						ipvs</p>
<ul>
<li>分析：会不会是service转发到Pod的ip:port出现问题呢？</li>
<li>过程：首先使用ipvsadm -L -n，查看ipvs是否能够负载均衡到pod的ip:port。继续查看pod的ip:port是否正常。</li>
<li>结果：ipvs存在对应的规则，以及pod是正常的，能够ping通的。</li>
</ul>
<p><img src="/container.github.io/images/image-20240303153531730.png" alt="image-20240303153531730"></p>
<p><img src="/container.github.io/images/image-20240303153614230.png" alt="image-20240303153614230"></p>
<ul>
<li>分析：以上情况说明，只能是service本身问题，或者从主机发送的icmp报文被拦截了。service本身只是一个虚拟ip，绑定在kube-ipvs0网卡中，当请求这个service的ClusterIP时，能够直接到达input链进行处理。所以service不太可能出现什么问题。那么，问题大概率是在ping命令发送的报文被拦截了。</li>
<li>过程：使用iptables -L -n -t命令查看kube-proxy和ipvs生成的链，查看包在经过内核处理的时候做了什么。</li>
<li>结果：kube-proxy创建了KUBE-IPVS-FILTER链拒绝了所有KUBE-IPVS-IPS中的IP。而KUBE-IPVS-IPS中的IP保存了所有service的ClusterIP。而在1.21版本的k8s中，并没有该KUBE-IPVS-FILTER链。</li>
</ul>
<p><img src="/container.github.io/images/image-20240303155719695.png" alt="image-20240303155719695"></p>
<p><img src="/container.github.io/images/image-20240303155830139.png" alt="image-20240303155830139"></p>
<p>​																						k8s-1.27</p>
</li>
<li><p>结论：</p>
<ul>
<li>在1.27版本的k8s中，增加了主机对service的ClusterIP的链，阻止了主机对service进行ping命令。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xichuanliang.github.io/container.github.io/2024/02/29/kubeadm-init-Finally/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/container.github.io/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/container.github.io/2024/02/29/kubeadm-init-Finally/" class="post-title-link" itemprop="url">kubeadm init (Finally)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-29 22:49:33 / 修改时间：22:50:00" itemprop="dateCreated datePublished" datetime="2024-02-29T22:49:33+08:00">2024-02-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Kubeadm-Init-finally"><a href="#Kubeadm-Init-finally" class="headerlink" title="Kubeadm Init (finally)"></a>Kubeadm Init (finally)</h2><ul>
<li>NewKubeletStartPhase：为节点写入Kubelet的配置文件，启动kubelet。<ul>
<li>kubelet的配置文件为&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;config.yaml。该函数如果发现kubelet服务的状态为inactive，执行相应的Kubeadm 命令能够重启kubelet。</li>
<li>将env变量写入&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;kubeadm-flags.env</li>
</ul>
</li>
<li>NewWaitControlPlanePhase：是在控制平面和 etcd 阶段之后运行的隐藏阶段，作用是等待控制面节点任务的执行，如果 kubelet 启动异常或者控制面节点崩溃将会停止后面的流程。<ul>
<li>任务：kubelet监视&#x2F;etc&#x2F;kubernetes&#x2F;manifest中的文件等待创建静态Pod。</li>
</ul>
</li>
<li>NewUploadConfigPhase：上传kubeadm配置和kubelet配置。<ul>
<li>主要是创建名称为kubeadm-config和kubelet-config的configmap</li>
<li>写入crisocket的信息（kubeadm.alpha.kubernetes.io&#x2F;cri-socket: unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;cri-dockerd.sock）到node资源中。</li>
</ul>
</li>
<li>NewUploadCertsPhase：上传证书。<ul>
<li>上传证书存入kubeam-certs的secret中。</li>
<li>当新的节点加入到control plane中时需要用到。</li>
</ul>
</li>
<li>NewMarkControlPlanePhase：对于master节点添加污点<ul>
<li>添加 node-role.kubernetes.io&#x2F;control-plane&#x3D;NoSchedule node.kubernetes.io&#x2F;exclude-from-external-load-balancers&#x3D;NoSchedule</li>
</ul>
</li>
<li>NewBootstrapTokenPhase：保证新节点能够加入集群中<ul>
<li>生成bootstrap token和ca证书configmap</li>
<li>创建RBAC规则，后续 node 可以通过生成的 token join加入集群。</li>
</ul>
</li>
<li>NewKubeletFinalizePhase：更换kubelet的证书<ul>
<li>在 TLS 引导后更新与 kubelet 相关的设置，其实就是将kubelet与kube-apiserver通信的kubeconfig文件中的证书替换成由kube-controller-manager签发返回的证书</li>
</ul>
</li>
<li>NewAddonPhase：通过 API安装一个 DNS 服务器 (CoreDNS) 和 kube-proxy 附加组件<ul>
<li>在kubeadm代码中已经保存了创建coreDNS的service，deployment，clusterole，ClusterRoleBinding。只需调用client-go的api就能创建coreDNS。</li>
<li>在kubeadm代码中已经保存了创建kube-proxy的service，daemonset，clusterole，ClusterRoleBinding。只需调用client-go的api就能创建kube-proxy。</li>
</ul>
</li>
<li>NewShowJoinCommandPhase：打印初始化成功的命令，同时为用户提供后续的操作指导，例如工作节点的加入等。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xichuanliang.github.io/container.github.io/2024/02/20/kubeadmInit-%E4%BA%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/container.github.io/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/container.github.io/2024/02/20/kubeadmInit-%E4%BA%94/" class="post-title-link" itemprop="url">kubeadmInit (五)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-20 21:53:17 / 修改时间：21:53:37" itemprop="dateCreated datePublished" datetime="2024-02-20T21:53:17+08:00">2024-02-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="kubeadm-Init-五"><a href="#kubeadm-Init-五" class="headerlink" title="kubeadm Init (五)"></a>kubeadm Init (五)</h2><p>创建kube-apiserver、kube-controller-manager、kube-scheduler的静态pod的yaml文件</p>
<ul>
<li>创建工作流<ul>
<li>该工作流中存在三个子工作流，分别用于创建apiserver、controller-manager、scheduler的静态pod文件</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControlPlanePhase</span><span class="params">()</span></span> workflow.Phase &#123;</span><br><span class="line">	phase := workflow.Phase&#123;</span><br><span class="line">		Name:  <span class="string">&quot;control-plane&quot;</span>,</span><br><span class="line">		Short: <span class="string">&quot;Generate all static Pod manifest files necessary to establish the control plane&quot;</span>,</span><br><span class="line">		Long:  cmdutil.MacroCommandLongDescription,</span><br><span class="line">		Phases: []workflow.Phase&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				Name:           <span class="string">&quot;all&quot;</span>,</span><br><span class="line">				Short:          <span class="string">&quot;Generate all static Pod manifest files&quot;</span>,</span><br><span class="line">				InheritFlags:   getControlPlanePhaseFlags(<span class="string">&quot;all&quot;</span>),</span><br><span class="line">				Example:        controlPlaneExample,</span><br><span class="line">				RunAllSiblings: <span class="literal">true</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">			newControlPlaneSubphase(kubeadmconstants.KubeAPIServer),</span><br><span class="line">			newControlPlaneSubphase(kubeadmconstants.KubeControllerManager),</span><br><span class="line">			newControlPlaneSubphase(kubeadmconstants.KubeScheduler),</span><br><span class="line">		&#125;,</span><br><span class="line">		Run: runControlPlanePhase,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> phase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>子工作流<ul>
<li>根据传入的参数不同，执行相应的工作流</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newControlPlaneSubphase</span><span class="params">(component <span class="type">string</span>)</span></span> workflow.Phase &#123;</span><br><span class="line">	phase := workflow.Phase&#123;</span><br><span class="line">		Name:         controlPlanePhaseProperties[component].name,</span><br><span class="line">		Short:        controlPlanePhaseProperties[component].short,</span><br><span class="line">		Run:          runControlPlaneSubphase(component),</span><br><span class="line">		InheritFlags: getControlPlanePhaseFlags(component),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> phase</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runControlPlaneSubphase</span><span class="params">(component <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(c workflow.RunData)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c workflow.RunData)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		data, ok := c.(InitData)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.New(<span class="string">&quot;control-plane phase invoked with an invalid data struct&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		cfg := data.Cfg()</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;[control-plane] Creating static Pod manifest for %q\n&quot;</span>, component)</span><br><span class="line">		<span class="keyword">return</span> controlplane.CreateStaticPodFiles(data.ManifestDir(), data.PatchesDir(), &amp;cfg.ClusterConfiguration, &amp;cfg.LocalAPIEndpoint, data.DryRun(), component)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建对应静态pod的yaml文件<ul>
<li>GetStaticPodSpecs()：获取静态的podspec，比如获得KubeAPIServer的podSpec、KubeControllerManager的podSpec以及KubeScheduler的podSpec。在这三个的podSpec文件中，主要是包含了pod内容器的启动命令、镜像名称、卷的挂载、探针等等。</li>
<li>最终将静态pod的yaml写入&#x2F;etc&#x2F;kubernetes&#x2F;manifests&#x2F;中</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateStaticPodFiles</span><span class="params">(manifestDir, patchesDir <span class="type">string</span>, cfg *kubeadmapi.ClusterConfiguration, endpoint *kubeadmapi.APIEndpoint, isDryRun <span class="type">bool</span>, componentNames ...<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// gets the StaticPodSpecs, actualized for the current ClusterConfiguration</span></span><br><span class="line">	klog.V(<span class="number">1</span>).Infoln(<span class="string">&quot;[control-plane] getting StaticPodSpecs&quot;</span>)</span><br><span class="line">	specs := GetStaticPodSpecs(cfg, endpoint, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> usersAndGroups *users.UsersAndGroups</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">if</span> features.Enabled(cfg.FeatureGates, features.RootlessControlPlane) &#123;</span><br><span class="line">		<span class="keyword">if</span> isDryRun &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;[control-plane] Would create users and groups for %+v to run as non-root\n&quot;</span>, componentNames)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			usersAndGroups, err = staticpodutil.GetUsersAndGroups()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;failed to create users and groups&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// creates required static pod specs</span></span><br><span class="line">	<span class="keyword">for</span> _, componentName := <span class="keyword">range</span> componentNames &#123;</span><br><span class="line">		<span class="comment">// retrieves the StaticPodSpec for given component</span></span><br><span class="line">		spec, exists := specs[componentName]</span><br><span class="line">		<span class="keyword">if</span> !exists &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Errorf(<span class="string">&quot;couldn&#x27;t retrieve StaticPodSpec for %q&quot;</span>, componentName)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// print all volumes that are mounted</span></span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> spec.Spec.Volumes &#123;</span><br><span class="line">			klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;[control-plane] adding volume %q for component %q&quot;</span>, v.Name, componentName)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> features.Enabled(cfg.FeatureGates, features.RootlessControlPlane) &#123;</span><br><span class="line">			<span class="keyword">if</span> isDryRun &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;[control-plane] Would update static pod manifest for %q to run run as non-root\n&quot;</span>, componentName)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> usersAndGroups != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> err := staticpodutil.RunComponentAsNonRoot(componentName, &amp;spec, usersAndGroups, cfg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;failed to run component %q as non-root&quot;</span>, componentName)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// if patchesDir is defined, patch the static Pod manifest</span></span><br><span class="line">		<span class="keyword">if</span> patchesDir != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			patchedSpec, err := staticpodutil.PatchStaticPod(&amp;spec, patchesDir, os.Stdout)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;failed to patch static Pod manifest file for %q&quot;</span>, componentName)</span><br><span class="line">			&#125;</span><br><span class="line">			spec = *patchedSpec</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// writes the StaticPodSpec to disk</span></span><br><span class="line">		<span class="keyword">if</span> err := staticpodutil.WriteStaticPodToDisk(componentName, manifestDir, spec); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;failed to create static pod manifest file for %q&quot;</span>, componentName)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		klog.V(<span class="number">1</span>).Infof(<span class="string">&quot;[control-plane] wrote static Pod manifest for component %q to %q\n&quot;</span>, componentName, kubeadmconstants.GetStaticPodFilepath(componentName, manifestDir))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据配置文件生成的相应的PodSpec</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStaticPodSpecs</span><span class="params">(cfg *kubeadmapi.ClusterConfiguration, endpoint *kubeadmapi.APIEndpoint, proxyEnvs []kubeadmapi.EnvVar)</span></span> <span class="keyword">map</span>[<span class="type">string</span>]v1.Pod &#123;</span><br><span class="line">	<span class="comment">// Get the required hostpath mounts</span></span><br><span class="line">	mounts := getHostPathVolumesForTheControlPlane(cfg)</span><br><span class="line">	<span class="keyword">if</span> proxyEnvs == <span class="literal">nil</span> &#123;</span><br><span class="line">		proxyEnvs = kubeadmutil.GetProxyEnvVars()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prepare static pod specs</span></span><br><span class="line">	staticPodSpecs := <span class="keyword">map</span>[<span class="type">string</span>]v1.Pod&#123;</span><br><span class="line">		kubeadmconstants.KubeAPIServer: staticpodutil.ComponentPod(v1.Container&#123;</span><br><span class="line">			Name:            kubeadmconstants.KubeAPIServer,</span><br><span class="line">			Image:           images.GetKubernetesImage(kubeadmconstants.KubeAPIServer, cfg),</span><br><span class="line">			ImagePullPolicy: v1.PullIfNotPresent,</span><br><span class="line">			Command:         getAPIServerCommand(cfg, endpoint),</span><br><span class="line">			VolumeMounts:    staticpodutil.VolumeMountMapToSlice(mounts.GetVolumeMounts(kubeadmconstants.KubeAPIServer)),</span><br><span class="line">			LivenessProbe:   staticpodutil.LivenessProbe(staticpodutil.GetAPIServerProbeAddress(endpoint), <span class="string">&quot;/livez&quot;</span>, endpoint.BindPort, v1.URISchemeHTTPS),</span><br><span class="line">			ReadinessProbe:  staticpodutil.ReadinessProbe(staticpodutil.GetAPIServerProbeAddress(endpoint), <span class="string">&quot;/readyz&quot;</span>, endpoint.BindPort, v1.URISchemeHTTPS),</span><br><span class="line">			StartupProbe:    staticpodutil.StartupProbe(staticpodutil.GetAPIServerProbeAddress(endpoint), <span class="string">&quot;/livez&quot;</span>, endpoint.BindPort, v1.URISchemeHTTPS, cfg.APIServer.TimeoutForControlPlane),</span><br><span class="line">			Resources:       staticpodutil.ComponentResources(<span class="string">&quot;250m&quot;</span>),</span><br><span class="line">			Env:             kubeadmutil.MergeKubeadmEnvVars(proxyEnvs, cfg.APIServer.ExtraEnvs),</span><br><span class="line">		&#125;, mounts.GetVolumes(kubeadmconstants.KubeAPIServer),</span><br><span class="line">			<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;kubeadmconstants.KubeAPIServerAdvertiseAddressEndpointAnnotationKey: endpoint.String()&#125;),</span><br><span class="line">		kubeadmconstants.KubeControllerManager: staticpodutil.ComponentPod(v1.Container&#123;</span><br><span class="line">			Name:            kubeadmconstants.KubeControllerManager,</span><br><span class="line">			Image:           images.GetKubernetesImage(kubeadmconstants.KubeControllerManager, cfg),</span><br><span class="line">			ImagePullPolicy: v1.PullIfNotPresent,</span><br><span class="line">			Command:         getControllerManagerCommand(cfg),</span><br><span class="line">			VolumeMounts:    staticpodutil.VolumeMountMapToSlice(mounts.GetVolumeMounts(kubeadmconstants.KubeControllerManager)),</span><br><span class="line">			LivenessProbe:   staticpodutil.LivenessProbe(staticpodutil.GetControllerManagerProbeAddress(cfg), <span class="string">&quot;/healthz&quot;</span>, kubeadmconstants.KubeControllerManagerPort, v1.URISchemeHTTPS),</span><br><span class="line">			StartupProbe:    staticpodutil.StartupProbe(staticpodutil.GetControllerManagerProbeAddress(cfg), <span class="string">&quot;/healthz&quot;</span>, kubeadmconstants.KubeControllerManagerPort, v1.URISchemeHTTPS, cfg.APIServer.TimeoutForControlPlane),</span><br><span class="line">			Resources:       staticpodutil.ComponentResources(<span class="string">&quot;200m&quot;</span>),</span><br><span class="line">			Env:             kubeadmutil.MergeKubeadmEnvVars(proxyEnvs, cfg.ControllerManager.ExtraEnvs),</span><br><span class="line">		&#125;, mounts.GetVolumes(kubeadmconstants.KubeControllerManager), <span class="literal">nil</span>),</span><br><span class="line">		kubeadmconstants.KubeScheduler: staticpodutil.ComponentPod(v1.Container&#123;</span><br><span class="line">			Name:            kubeadmconstants.KubeScheduler,</span><br><span class="line">			Image:           images.GetKubernetesImage(kubeadmconstants.KubeScheduler, cfg),</span><br><span class="line">			ImagePullPolicy: v1.PullIfNotPresent,</span><br><span class="line">			Command:         getSchedulerCommand(cfg),</span><br><span class="line">			VolumeMounts:    staticpodutil.VolumeMountMapToSlice(mounts.GetVolumeMounts(kubeadmconstants.KubeScheduler)),</span><br><span class="line">			LivenessProbe:   staticpodutil.LivenessProbe(staticpodutil.GetSchedulerProbeAddress(cfg), <span class="string">&quot;/healthz&quot;</span>, kubeadmconstants.KubeSchedulerPort, v1.URISchemeHTTPS),</span><br><span class="line">			StartupProbe:    staticpodutil.StartupProbe(staticpodutil.GetSchedulerProbeAddress(cfg), <span class="string">&quot;/healthz&quot;</span>, kubeadmconstants.KubeSchedulerPort, v1.URISchemeHTTPS, cfg.APIServer.TimeoutForControlPlane),</span><br><span class="line">			Resources:       staticpodutil.ComponentResources(<span class="string">&quot;100m&quot;</span>),</span><br><span class="line">			Env:             kubeadmutil.MergeKubeadmEnvVars(proxyEnvs, cfg.Scheduler.ExtraEnvs),</span><br><span class="line">		&#125;, mounts.GetVolumes(kubeadmconstants.KubeScheduler), <span class="literal">nil</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> staticPodSpecs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xichuanliang.github.io/container.github.io/2024/02/18/kubeadmInit-%E5%9B%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/container.github.io/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/container.github.io/2024/02/18/kubeadmInit-%E5%9B%9B/" class="post-title-link" itemprop="url">kubeadmInit (四)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-18 20:45:52 / 修改时间：20:46:24" itemprop="dateCreated datePublished" datetime="2024-02-18T20:45:52+08:00">2024-02-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="kubeadm-Init-四"><a href="#kubeadm-Init-四" class="headerlink" title="kubeadm Init (四)"></a>kubeadm Init (四)</h2><p>对于local etcd，产生创建etcd的yaml文件</p>
<ul>
<li>创建工作流</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEtcdPhase</span><span class="params">()</span></span> workflow.Phase &#123;</span><br><span class="line">	phase := workflow.Phase&#123;</span><br><span class="line">		Name:  <span class="string">&quot;etcd&quot;</span>,</span><br><span class="line">		Short: <span class="string">&quot;Generate static Pod manifest file for local etcd&quot;</span>,</span><br><span class="line">		Long:  cmdutil.MacroCommandLongDescription,</span><br><span class="line">		Phases: []workflow.Phase&#123;</span><br><span class="line">			newEtcdLocalSubPhase(),</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> phase</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newEtcdLocalSubPhase</span><span class="params">()</span></span> workflow.Phase &#123;</span><br><span class="line">	phase := workflow.Phase&#123;</span><br><span class="line">		Name:         <span class="string">&quot;local&quot;</span>,</span><br><span class="line">		Short:        <span class="string">&quot;Generate the static Pod manifest file for a local, single-node local etcd instance&quot;</span>,</span><br><span class="line">		Example:      etcdLocalExample,</span><br><span class="line">        <span class="comment">// 此处为创建etcd的yaml文件的入口</span></span><br><span class="line">		Run:          runEtcdPhaseLocal(),</span><br><span class="line">		InheritFlags: getEtcdPhaseFlags(),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> phase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建etcd.yaml文件<ul>
<li>如果etcd与master节点为同一节点，那就创建etcd.yaml，否则跳过创建步骤</li>
<li>CreateLocalEtcdStaticPodManifestFile()：该方法创建etcd.yaml，并且写到指定路径中</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runEtcdPhaseLocal</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(c workflow.RunData)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c workflow.RunData)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		data, ok := c.(InitData)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.New(<span class="string">&quot;etcd phase invoked with an invalid data struct&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		cfg := data.Cfg()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Add etcd static pod spec only if external etcd is not configured</span></span><br><span class="line">		<span class="keyword">if</span> cfg.Etcd.External == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// creates target folder if doesn&#x27;t exist already</span></span><br><span class="line">			<span class="keyword">if</span> !data.DryRun() &#123;</span><br><span class="line">				<span class="comment">// Create the etcd data directory</span></span><br><span class="line">				<span class="keyword">if</span> err := etcdutil.CreateDataDirectory(cfg.Etcd.Local.DataDir); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;[etcd] Would ensure that %q directory is present\n&quot;</span>, cfg.Etcd.Local.DataDir)</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;[etcd] Creating static Pod manifest for local etcd in %q\n&quot;</span>, data.ManifestDir())</span><br><span class="line">			<span class="keyword">if</span> err := etcdphase.CreateLocalEtcdStaticPodManifestFile(data.ManifestDir(), data.PatchesDir(), cfg.NodeRegistration.Name, &amp;cfg.ClusterConfiguration, &amp;cfg.LocalAPIEndpoint, data.DryRun()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;error creating local etcd static pod manifest file&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			klog.V(<span class="number">1</span>).Infoln(<span class="string">&quot;[etcd] External etcd mode. Skipping the creation of a manifest for local etcd&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建etcdpodspec，设置启动命令和参数<ul>
<li>etcd中挂载两个volume，其中一个etcd-data，保存的是在内存中顺序化记录下的所有用户对节点的变更操作，以及对数据进行便捷查询的索引等等。持久化的方式使用的是WAL和快照结合的方式，在某个时间点，生成一个对当前时间点数据的快照信息，然后再将某个时间点以后的操作，通过WAL的形式，先写日志，随后进行操作，达到事务的一致性。另一个是etcd-certs，保存etcd同其他组件通信所需的证书。</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareAndWriteEtcdStaticPod</span><span class="params">(manifestDir <span class="type">string</span>, patchesDir <span class="type">string</span>, cfg *kubeadmapi.ClusterConfiguration, endpoint *kubeadmapi.APIEndpoint, nodeName <span class="type">string</span>, initialCluster []etcdutil.Member, isDryRun <span class="type">bool</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// gets etcd StaticPodSpec, actualized for the current ClusterConfiguration and the new list of etcd members</span></span><br><span class="line">	spec := GetEtcdPodSpec(cfg, endpoint, nodeName, initialCluster)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> usersAndGroups *users.UsersAndGroups</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">if</span> features.Enabled(cfg.FeatureGates, features.RootlessControlPlane) &#123;</span><br><span class="line">		<span class="keyword">if</span> isDryRun &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;[etcd] Would create users and groups for %q to run as non-root\n&quot;</span>, kubeadmconstants.Etcd)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;[etcd] Would update static pod manifest for %q to run run as non-root\n&quot;</span>, kubeadmconstants.Etcd)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			usersAndGroups, err = staticpodutil.GetUsersAndGroups()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;failed to create users and groups&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// usersAndGroups is nil on non-linux.</span></span><br><span class="line">			<span class="keyword">if</span> usersAndGroups != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> err := staticpodutil.RunComponentAsNonRoot(kubeadmconstants.Etcd, &amp;spec, usersAndGroups, cfg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;failed to run component %q as non-root&quot;</span>, kubeadmconstants.Etcd)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if patchesDir is defined, patch the static Pod manifest</span></span><br><span class="line">	<span class="keyword">if</span> patchesDir != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		patchedSpec, err := staticpodutil.PatchStaticPod(&amp;spec, patchesDir, os.Stdout)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;failed to patch static Pod manifest file for %q&quot;</span>, kubeadmconstants.Etcd)</span><br><span class="line">		&#125;</span><br><span class="line">		spec = *patchedSpec</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// writes etcd StaticPod to disk</span></span><br><span class="line">	<span class="keyword">if</span> err := staticpodutil.WriteStaticPodToDisk(kubeadmconstants.Etcd, manifestDir, spec); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetEtcdPodSpec</span><span class="params">(cfg *kubeadmapi.ClusterConfiguration, endpoint *kubeadmapi.APIEndpoint, nodeName <span class="type">string</span>, initialCluster []etcdutil.Member)</span></span> v1.Pod &#123;</span><br><span class="line">	pathType := v1.HostPathDirectoryOrCreate</span><br><span class="line">	etcdMounts := <span class="keyword">map</span>[<span class="type">string</span>]v1.Volume&#123;</span><br><span class="line">		etcdVolumeName:  staticpodutil.NewVolume(etcdVolumeName, cfg.Etcd.Local.DataDir, &amp;pathType),</span><br><span class="line">		certsVolumeName: staticpodutil.NewVolume(certsVolumeName, cfg.CertificatesDir+<span class="string">&quot;/etcd&quot;</span>, &amp;pathType),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// probeHostname returns the correct localhost IP address family based on the endpoint AdvertiseAddress</span></span><br><span class="line">	probeHostname, probePort, probeScheme := staticpodutil.GetEtcdProbeEndpoint(&amp;cfg.Etcd, utilsnet.IsIPv6String(endpoint.AdvertiseAddress))</span><br><span class="line">	<span class="keyword">return</span> staticpodutil.ComponentPod(</span><br><span class="line">		v1.Container&#123;</span><br><span class="line">			Name:            kubeadmconstants.Etcd,</span><br><span class="line">			Command:         getEtcdCommand(cfg, endpoint, nodeName, initialCluster),</span><br><span class="line">			Image:           images.GetEtcdImage(cfg),</span><br><span class="line">			ImagePullPolicy: v1.PullIfNotPresent,</span><br><span class="line">			<span class="comment">// Mount the etcd datadir path read-write so etcd can store data in a more persistent manner</span></span><br><span class="line">			VolumeMounts: []v1.VolumeMount&#123;</span><br><span class="line">				staticpodutil.NewVolumeMount(etcdVolumeName, cfg.Etcd.Local.DataDir, <span class="literal">false</span>),</span><br><span class="line">				staticpodutil.NewVolumeMount(certsVolumeName, cfg.CertificatesDir+<span class="string">&quot;/etcd&quot;</span>, <span class="literal">false</span>),</span><br><span class="line">			&#125;,</span><br><span class="line">			Resources: v1.ResourceRequirements&#123;</span><br><span class="line">				Requests: v1.ResourceList&#123;</span><br><span class="line">					v1.ResourceCPU:    resource.MustParse(<span class="string">&quot;100m&quot;</span>),</span><br><span class="line">					v1.ResourceMemory: resource.MustParse(<span class="string">&quot;100Mi&quot;</span>),</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;,</span><br><span class="line">			LivenessProbe: staticpodutil.LivenessProbe(probeHostname, <span class="string">&quot;/health?exclude=NOSPACE&amp;serializable=true&quot;</span>, probePort, probeScheme),</span><br><span class="line">			StartupProbe:  staticpodutil.StartupProbe(probeHostname, <span class="string">&quot;/health?serializable=false&quot;</span>, probePort, probeScheme, cfg.APIServer.TimeoutForControlPlane),</span><br><span class="line">			Env:           kubeadmutil.MergeKubeadmEnvVars(cfg.Etcd.Local.ExtraEnvs),</span><br><span class="line">		&#125;,</span><br><span class="line">		etcdMounts,</span><br><span class="line">		<span class="comment">// etcd will listen on the advertise address of the API server, in a different port (2379)</span></span><br><span class="line">		<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;kubeadmconstants.EtcdAdvertiseClientUrlsAnnotationKey: etcdutil.GetClientURL(endpoint)&#125;,</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getEtcdCommand</span><span class="params">(cfg *kubeadmapi.ClusterConfiguration, endpoint *kubeadmapi.APIEndpoint, nodeName <span class="type">string</span>, initialCluster []etcdutil.Member)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// localhost IP family should be the same that the AdvertiseAddress</span></span><br><span class="line">	etcdLocalhostAddress := <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">	<span class="keyword">if</span> utilsnet.IsIPv6String(endpoint.AdvertiseAddress) &#123;</span><br><span class="line">		etcdLocalhostAddress = <span class="string">&quot;::1&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	defaultArguments := []kubeadmapi.Arg&#123;</span><br><span class="line">		&#123;Name: <span class="string">&quot;name&quot;</span>, Value: nodeName&#125;,</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> start using --initial-corrupt-check once the graduated flag is available,</span></span><br><span class="line">		<span class="comment">// https://github.com/kubernetes/kubeadm/issues/2676</span></span><br><span class="line">		&#123;Name: <span class="string">&quot;experimental-initial-corrupt-check&quot;</span>, Value: <span class="string">&quot;true&quot;</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;listen-client-urls&quot;</span>, Value: fmt.Sprintf(<span class="string">&quot;%s,%s&quot;</span>, etcdutil.GetClientURLByIP(etcdLocalhostAddress), etcdutil.GetClientURL(endpoint))&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;advertise-client-urls&quot;</span>, Value: etcdutil.GetClientURL(endpoint)&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;listen-peer-urls&quot;</span>, Value: etcdutil.GetPeerURL(endpoint)&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;initial-advertise-peer-urls&quot;</span>, Value: etcdutil.GetPeerURL(endpoint)&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;data-dir&quot;</span>, Value: cfg.Etcd.Local.DataDir&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;cert-file&quot;</span>, Value: filepath.Join(cfg.CertificatesDir, kubeadmconstants.EtcdServerCertName)&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;key-file&quot;</span>, Value: filepath.Join(cfg.CertificatesDir, kubeadmconstants.EtcdServerKeyName)&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;trusted-ca-file&quot;</span>, Value: filepath.Join(cfg.CertificatesDir, kubeadmconstants.EtcdCACertName)&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;client-cert-auth&quot;</span>, Value: <span class="string">&quot;true&quot;</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;peer-cert-file&quot;</span>, Value: filepath.Join(cfg.CertificatesDir, kubeadmconstants.EtcdPeerCertName)&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;peer-key-file&quot;</span>, Value: filepath.Join(cfg.CertificatesDir, kubeadmconstants.EtcdPeerKeyName)&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;peer-trusted-ca-file&quot;</span>, Value: filepath.Join(cfg.CertificatesDir, kubeadmconstants.EtcdCACertName)&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;peer-client-cert-auth&quot;</span>, Value: <span class="string">&quot;true&quot;</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;snapshot-count&quot;</span>, Value: <span class="string">&quot;10000&quot;</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;listen-metrics-urls&quot;</span>, Value: fmt.Sprintf(<span class="string">&quot;http://%s&quot;</span>, net.JoinHostPort(etcdLocalhostAddress, strconv.Itoa(kubeadmconstants.EtcdMetricsPort)))&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;experimental-watch-progress-notify-interval&quot;</span>, Value: <span class="string">&quot;5s&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(initialCluster) == <span class="number">0</span> &#123;</span><br><span class="line">		defaultArguments = kubeadmapi.SetArgValues(defaultArguments, <span class="string">&quot;initial-cluster&quot;</span>, fmt.Sprintf(<span class="string">&quot;%s=%s&quot;</span>, nodeName, etcdutil.GetPeerURL(endpoint)), <span class="number">1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// NB. the joining etcd member should be part of the initialCluster list</span></span><br><span class="line">		endpoints := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> _, member := <span class="keyword">range</span> initialCluster &#123;</span><br><span class="line">			endpoints = <span class="built_in">append</span>(endpoints, fmt.Sprintf(<span class="string">&quot;%s=%s&quot;</span>, member.Name, member.PeerURL))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		defaultArguments = kubeadmapi.SetArgValues(defaultArguments, <span class="string">&quot;initial-cluster&quot;</span>, strings.Join(endpoints, <span class="string">&quot;,&quot;</span>), <span class="number">1</span>)</span><br><span class="line">		defaultArguments = kubeadmapi.SetArgValues(defaultArguments, <span class="string">&quot;initial-cluster-state&quot;</span>, <span class="string">&quot;existing&quot;</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	command := []<span class="type">string</span>&#123;<span class="string">&quot;etcd&quot;</span>&#125;</span><br><span class="line">	command = <span class="built_in">append</span>(command, kubeadmutil.ArgumentsToCommand(defaultArguments, cfg.Etcd.Local.ExtraArgs)...)</span><br><span class="line">	<span class="keyword">return</span> command</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xichuanliang.github.io/container.github.io/2024/01/28/kubeadmInit-%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/container.github.io/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/container.github.io/2024/01/28/kubeadmInit-%E4%B8%89/" class="post-title-link" itemprop="url">kubeadmInit (三)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-28 22:31:39 / 修改时间：22:31:59" itemprop="dateCreated datePublished" datetime="2024-01-28T22:31:39+08:00">2024-01-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="kubeadm-Init-三"><a href="#kubeadm-Init-三" class="headerlink" title="kubeadm Init (三)"></a>kubeadm Init (三)</h2><p>kubeadm进入第三个阶段(phases.NewKubeConfigPhase())，即创建出master节点所需的所有的conf文件，以及kubeconfig，分别为admin.conf、controller-manager.conf、scheduler.conf、kubelet.conf。在这一阶段生成的conf文件是根据ca.crt以及ca.key生成的。</p>
<ol>
<li>创建工作流<ul>
<li>NewKubeConfigFilePhase()：根据name，构建每个子工作流，用于创建不同的config文件，比如admin.conf、kubelet.conf等等。</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewKubeConfigPhase</span><span class="params">()</span></span> workflow.Phase &#123;</span><br><span class="line">	<span class="keyword">return</span> workflow.Phase&#123;</span><br><span class="line">		Name:  <span class="string">&quot;kubeconfig&quot;</span>,</span><br><span class="line">		Short: <span class="string">&quot;Generate all kubeconfig files necessary to establish the control plane and the admin kubeconfig file&quot;</span>,</span><br><span class="line">		Long:  cmdutil.MacroCommandLongDescription,</span><br><span class="line">		Phases: []workflow.Phase&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				Name:           <span class="string">&quot;all&quot;</span>,</span><br><span class="line">				Short:          <span class="string">&quot;Generate all kubeconfig files&quot;</span>,</span><br><span class="line">				InheritFlags:   getKubeConfigPhaseFlags(<span class="string">&quot;all&quot;</span>),</span><br><span class="line">				RunAllSiblings: <span class="literal">true</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">			NewKubeConfigFilePhase(kubeadmconstants.AdminKubeConfigFileName),</span><br><span class="line">			NewKubeConfigFilePhase(kubeadmconstants.SuperAdminKubeConfigFileName),</span><br><span class="line">			NewKubeConfigFilePhase(kubeadmconstants.KubeletKubeConfigFileName),</span><br><span class="line">			NewKubeConfigFilePhase(kubeadmconstants.ControllerManagerKubeConfigFileName),</span><br><span class="line">			NewKubeConfigFilePhase(kubeadmconstants.SchedulerKubeConfigFileName),</span><br><span class="line">		&#125;,</span><br><span class="line">		Run: runKubeConfig,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根据每个子工作流，创建对应的config文件<ul>
<li>构建的子工作流中执行的Run方法，runKubeConfigFile()</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewKubeConfigFilePhase</span><span class="params">(kubeConfigFileName <span class="type">string</span>)</span></span> workflow.Phase &#123;</span><br><span class="line">	<span class="keyword">return</span> workflow.Phase&#123;</span><br><span class="line">		Name:         kubeconfigFilePhaseProperties[kubeConfigFileName].name,</span><br><span class="line">		Short:        kubeconfigFilePhaseProperties[kubeConfigFileName].short,</span><br><span class="line">		Long:         fmt.Sprintf(kubeconfigFilePhaseProperties[kubeConfigFileName].long, kubeConfigFileName),</span><br><span class="line">		Run:          runKubeConfigFile(kubeConfigFileName),</span><br><span class="line">		InheritFlags: getKubeConfigPhaseFlags(kubeConfigFileName),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行runKubeConfigFile，同证书一起创建config文件<ul>
<li>如果使用外部的ca颁发证书，直接返回</li>
<li>data.CertificateWriteDir()：将各个证书的存储路径保存到kubeadm-init.yaml中的InitConfiguration中</li>
<li>CreateKubeConfigFile()：创建所需的conf文件或者使用已经存在的</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runKubeConfigFile</span><span class="params">(kubeConfigFileName <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(workflow.RunData)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c workflow.RunData)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		data, ok := c.(InitData)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.New(<span class="string">&quot;kubeconfig phase invoked with an invalid data struct&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// if external CA mode, skip certificate authority generation</span></span><br><span class="line">		<span class="keyword">if</span> data.ExternalCA() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;[kubeconfig] External CA mode: Using user provided %s\n&quot;</span>, kubeConfigFileName)</span><br><span class="line">			<span class="comment">// If using an external CA while dryrun, copy kubeconfig files to dryrun dir for later use</span></span><br><span class="line">			<span class="keyword">if</span> data.DryRun() &#123;</span><br><span class="line">				err := kubeadmutil.CopyFile(filepath.Join(kubeadmconstants.KubernetesDir, kubeConfigFileName), filepath.Join(data.KubeConfigDir(), kubeConfigFileName))</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;could not copy %s to dry run directory %s&quot;</span>, kubeConfigFileName, data.KubeConfigDir())</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// if dryrunning, reads certificates from a temporary folder (and defer restore to the path originally specified by the user)</span></span><br><span class="line">		cfg := data.Cfg()</span><br><span class="line">		cfg.CertificatesDir = data.CertificateWriteDir()</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; cfg.CertificatesDir = data.CertificateDir() &#125;()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// creates the KubeConfig file (or use existing)</span></span><br><span class="line">		<span class="keyword">return</span> kubeconfigphase.CreateKubeConfigFile(kubeConfigFileName, data.KubeConfigDir(), data.Cfg())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建conf或者使用已经存在的conf<ul>
<li>getKubeConfigSpecs()：<ul>
<li>加载ca.crt和ca.key从对应的文件夹中，ca.crt一般保存在&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;文件中</li>
<li>验证ca.crt的有效时间，查看当前的证书是否还在有效期内，证书的有效期一般为365天</li>
<li>为master节点设置ControlPlaneEndpoint或者LocalApiEndpoint。ControlPlaneEndpoint在多master节点的时候做负载均衡，LocalApiEndpoint就是master所在节点的IP。其中如果没有显示这是ControlPlaneEndpoint时，就将LocalApiEndpoint的ip和端口作为ControlPlaneEndpoint的Ip和端口</li>
<li>初始化admin.conf、super-admin.conf、kubelet.conf、controller-manager.conf以及scheduler.conf的kubeconfigSpec。</li>
<li>将ca.crt以及ca.key保存在config文件中</li>
</ul>
</li>
<li>buildKubeConfigFromSpec()：<ul>
<li>创建新的key和crt</li>
<li>根据新的key和crt创建出conf，每个conf都是由一个基础conf构造而来的。一个基础conf(base conf)包括cluster的相关信息，cluster的name、url、ca.crt、users以及context。</li>
</ul>
</li>
<li>createKubeConfigFileIfNotExists()：<ul>
<li>获取conf路径</li>
<li>验证conf的有效性。加载conf，判断文件是否存在，如果存在，判断CA、URL是否相同。如果都相同就用存在的conf。如果conf不存在或者CA不同或者URL不同，就报错。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateKubeConfigFile</span><span class="params">(kubeConfigFileName <span class="type">string</span>, outDir <span class="type">string</span>, cfg *kubeadmapi.InitConfiguration)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	klog.V(<span class="number">1</span>).Infof(<span class="string">&quot;creating kubeconfig file for %s&quot;</span>, kubeConfigFileName)</span><br><span class="line">	<span class="keyword">return</span> createKubeConfigFiles(outDir, cfg, kubeConfigFileName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createKubeConfigFiles</span><span class="params">(outDir <span class="type">string</span>, cfg *kubeadmapi.InitConfiguration, kubeConfigFileNames ...<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// gets the KubeConfigSpecs, actualized for the current InitConfiguration</span></span><br><span class="line">	specs, err := getKubeConfigSpecs(cfg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, kubeConfigFileName := <span class="keyword">range</span> kubeConfigFileNames &#123;</span><br><span class="line">		<span class="comment">// retrieves the KubeConfigSpec for given kubeConfigFileName</span></span><br><span class="line">		spec, exists := specs[kubeConfigFileName]</span><br><span class="line">		<span class="keyword">if</span> !exists &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Errorf(<span class="string">&quot;couldn&#x27;t retrieve KubeConfigSpec for %s&quot;</span>, kubeConfigFileName)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// builds the KubeConfig object</span></span><br><span class="line">		config, err := buildKubeConfigFromSpec(spec, cfg.ClusterName, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// writes the kubeconfig to disk if it does not exist</span></span><br><span class="line">		<span class="keyword">if</span> err = createKubeConfigFileIfNotExists(outDir, kubeConfigFileName, config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>以controller-manager.conf为例<ul>
<li>certificate-authority-data：用于验证kube-apiserver服务器证书的CA根证书</li>
<li>client-certificate-data：用于访问kube-apiserver的客户端证书</li>
<li>client-key-data：客户端证书对应的私钥</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">cluster:</span></span><br><span class="line">    <span class="attr">certificate-authority-data:</span> <span class="string">LS0tLS1CRUdJTiBDRVJUSUZJQ0FXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXVElGSUNBVEUtLS0tLQo=</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">https://apiserver.cluster.local:6443</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">contexts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">context:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">kubernetes</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">system:kube-controller-manager</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:kube-controller-manager@kubernetes</span></span><br><span class="line"><span class="attr">current-context:</span> <span class="string">system:kube-controller-manager@kubernetes</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Config</span></span><br><span class="line"><span class="attr">preferences:</span> &#123;&#125;</span><br><span class="line"><span class="attr">users:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">system:kube-controller-manager</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">client-certificate-data:</span> <span class="string">LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLSXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span></span><br><span class="line">    <span class="attr">client-key-data:</span> <span class="string">LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xichuanliang.github.io/container.github.io/2024/01/24/kubeadmInit-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/container.github.io/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/container.github.io/2024/01/24/kubeadmInit-%E4%BA%8C/" class="post-title-link" itemprop="url">kubeadmInit (二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-24 21:21:43 / 修改时间：21:22:26" itemprop="dateCreated datePublished" datetime="2024-01-24T21:21:43+08:00">2024-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="kubeadm-Init-二"><a href="#kubeadm-Init-二" class="headerlink" title="kubeadm Init (二)"></a>kubeadm Init (二)</h2><p>kubeadm进入第二个阶段(phases.NewCertsPhase())，即证书生成与校验。生成一个自签名的CA证书为集群中的每一个组件进行身份识别的过程。</p>
<p>kubeadm会在初始化集群前，生成组件之间通信所需的证书，证书的保存位置默认在&#x2F;etc&#x2F;kubernetes&#x2F;pki，证书的过期时间默认为365天。在k8s中，组件之间通信是通过ssl进行通信，则需要csr(证书申请文件)、key(私钥)共同向ca申请证书，则在&#x2F;etc&#x2F;kubernetes&#x2F;pki中可以看到两种文件，xxx.crt和xxx.key，分别是私钥和申请后得到的证书。</p>
<p>kubeam可使用命令：kubeadm certs -h 查看所有的有关证书的命令，可通过kubeadm certs renew all重新生成各种证书。</p>
<ol>
<li>初始化CertsPhase()<ul>
<li>newCertSubPhases()生成各个组件所需的证书</li>
<li>runCerts</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCertsPhase</span><span class="params">()</span></span> workflow.Phase &#123;</span><br><span class="line">	<span class="keyword">return</span> workflow.Phase&#123;</span><br><span class="line">		Name:   <span class="string">&quot;certs&quot;</span>,</span><br><span class="line">		Short:  <span class="string">&quot;Certificate generation&quot;</span>,</span><br><span class="line">		Phases: newCertSubPhases(),</span><br><span class="line">		Run:    runCerts,</span><br><span class="line">		Long:   cmdutil.MacroCommandLongDescription,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化每一个组件所需的证书<ul>
<li>GetDefaultCertList()：各个组件通信所需的证书列表，包括apiserver与kubelet、apiserver与etcd等等互相通信的组件。</li>
<li>newCertSubPhase()：初始化每一个certsphase的phase，并执行runCAPhase()。</li>
<li>runCAPhase()：根据证书列表生成xxx.key和xxx.crt。</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCertSubPhases</span><span class="params">()</span></span> []workflow.Phase &#123;</span><br><span class="line">	subPhases := []workflow.Phase&#123;&#125;</span><br><span class="line">	<span class="comment">// All subphase</span></span><br><span class="line">	allPhase := workflow.Phase&#123;</span><br><span class="line">		Name:           <span class="string">&quot;all&quot;</span>,</span><br><span class="line">		Short:          <span class="string">&quot;Generate all certificates&quot;</span>,</span><br><span class="line">		InheritFlags:   getCertPhaseFlags(<span class="string">&quot;all&quot;</span>),</span><br><span class="line">		RunAllSiblings: <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	subPhases = <span class="built_in">append</span>(subPhases, allPhase)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This loop assumes that GetDefaultCertList() always returns a list of</span></span><br><span class="line">	<span class="comment">// certificate that is preceded by the CAs that sign them.</span></span><br><span class="line">	<span class="keyword">var</span> lastCACert *certsphase.KubeadmCert</span><br><span class="line">	<span class="keyword">for</span> _, cert := <span class="keyword">range</span> certsphase.GetDefaultCertList() &#123;</span><br><span class="line">		<span class="keyword">var</span> phase workflow.Phase</span><br><span class="line">		<span class="keyword">if</span> cert.CAName == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			phase = newCertSubPhase(cert, runCAPhase(cert))</span><br><span class="line">			lastCACert = cert</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			phase = newCertSubPhase(cert, runCertPhase(cert, lastCACert))</span><br><span class="line">		&#125;</span><br><span class="line">		subPhases = <span class="built_in">append</span>(subPhases, phase)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// SA creates the private/public key pair, which doesn&#x27;t use x509 at all</span></span><br><span class="line">	saPhase := workflow.Phase&#123;</span><br><span class="line">		Name:         <span class="string">&quot;sa&quot;</span>,</span><br><span class="line">		Short:        <span class="string">&quot;Generate a private key for signing service account tokens along with its public key&quot;</span>,</span><br><span class="line">		Long:         saKeyLongDesc,</span><br><span class="line">		Run:          runCertsSa,</span><br><span class="line">		InheritFlags: []<span class="type">string</span>&#123;options.CertificatesDir&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	subPhases = <span class="built_in">append</span>(subPhases, saPhase)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> subPhases</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成的证书列表，包括各个组件的证书</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDefaultCertList</span><span class="params">()</span></span> Certificates </span><br><span class="line">	<span class="keyword">return</span> Certificates&#123;</span><br><span class="line">		KubeadmCertRootCA(),</span><br><span class="line">		KubeadmCertAPIServer(),</span><br><span class="line">		KubeadmCertKubeletClient(),</span><br><span class="line">		<span class="comment">// Front Proxy certs</span></span><br><span class="line">		KubeadmCertFrontProxyCA(),</span><br><span class="line">		KubeadmCertFrontProxyClient(),</span><br><span class="line">		<span class="comment">// etcd certs</span></span><br><span class="line">		KubeadmCertEtcdCA(),</span><br><span class="line">		KubeadmCertEtcdServer(),</span><br><span class="line">		KubeadmCertEtcdPeer(),</span><br><span class="line">		KubeadmCertEtcdHealthcheck(),</span><br><span class="line">		KubeadmCertEtcdAPIClient(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xichuanliang.github.io/container.github.io/2024/01/07/kubeadmInit-%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/container.github.io/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/container.github.io/2024/01/07/kubeadmInit-%E4%B8%80/" class="post-title-link" itemprop="url">kubeadmInit (一)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-07 20:08:44 / 修改时间：20:09:37" itemprop="dateCreated datePublished" datetime="2024-01-07T20:08:44+08:00">2024-01-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="kubeadm-Init"><a href="#kubeadm-Init" class="headerlink" title="kubeadm Init"></a>kubeadm Init</h1><p>kubeadm 是一个 Kubernetes 集群引导工具，用于简化在 Linux 系统上初始化和设置 Kubernetes 控制平面节点（master节点）和工作节点（worker节点）。它的目标是降低 Kubernetes 部署的难度，使得用户可以更容易地搭建一个符合最佳实践的 Kubernetes 集群。</p>
<p>本文从源码的角度介绍kubeadm init命令，该命令用于初始化一个k8s集群节点。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.xxx.xxx \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--kubernetes-version=v1.23.0 \</span><br><span class="line">--service-cidr=10.96.0.0/12 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>

<ol>
<li><p>通过cobra框架引入kubeadm init命令</p>
<ul>
<li>通过initRunner.Run(args)命令，真正开始执行kubeadm init命令</li>
<li>AddInitConfigFlags()，添加k8s初始化的参数，比如–skip-phases&#x3D;xxx，添加另一个节点作为master节点，设置vip的ip</li>
<li>AddClusterConfigFlags()，添加k8s集群的配置，比如网络配置，k8s版本，控制平面ip，镜像仓库地址</li>
<li>AddInitOtherFlags()，添加额外的配置文件，比如kubeconfig的位置等等</li>
<li>initRunner.SetAdditionalFlags()，给api server、controll manager、scheduler添加默认的额外的配置，比如日志的路径以及其他相关信息</li>
<li>initRunner.AppendPhase()，将K8s初始化的每个步骤添加进命令中</li>
<li>initRunner.SetDataInitializer()，判断是否跳过cri的检查，是否跳过DNSPhase、ProxyPhase，以及其他的–skip-phases&#x3D;xxx指令</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCmdInit</span><span class="params">(out io.Writer, initOptions *initOptions)</span></span> *cobra.Command &#123;</span><br><span class="line">	<span class="keyword">if</span> initOptions == <span class="literal">nil</span> &#123;</span><br><span class="line">		initOptions = newInitOptions()</span><br><span class="line">	&#125;</span><br><span class="line">	initRunner := workflow.NewRunner()</span><br><span class="line"></span><br><span class="line">	cmd := &amp;cobra.Command&#123;</span><br><span class="line">		Use:   <span class="string">&quot;init&quot;</span>,</span><br><span class="line">		Short: <span class="string">&quot;Run this command in order to set up the Kubernetes control plane&quot;</span>,</span><br><span class="line">		RunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			c, err := initRunner.InitData(args)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			data := c.(*initData)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;[init] Using Kubernetes version: %s\n&quot;</span>, data.cfg.KubernetesVersion)</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> initRunner.Run(args)</span><br><span class="line">		&#125;,</span><br><span class="line">		Args: cobra.NoArgs,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// add flags to the init command.</span></span><br><span class="line">	<span class="comment">// init command local flags could be eventually inherited by the sub-commands automatically generated for phases</span></span><br><span class="line">	AddInitConfigFlags(cmd.Flags(), initOptions.externalInitCfg)</span><br><span class="line">	AddClusterConfigFlags(cmd.Flags(), initOptions.externalClusterCfg, &amp;initOptions.featureGatesString)</span><br><span class="line">	AddInitOtherFlags(cmd.Flags(), initOptions)</span><br><span class="line">	initOptions.bto.AddTokenFlag(cmd.Flags())</span><br><span class="line">	initOptions.bto.AddTTLFlag(cmd.Flags())</span><br><span class="line">	options.AddImageMetaFlags(cmd.Flags(), &amp;initOptions.externalClusterCfg.ImageRepository)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// defines additional flag that are not used by the init command but that could be eventually used</span></span><br><span class="line">	<span class="comment">// by the sub-commands automatically generated for phases</span></span><br><span class="line">	initRunner.SetAdditionalFlags(<span class="function"><span class="keyword">func</span><span class="params">(flags *flag.FlagSet)</span></span> &#123;</span><br><span class="line">		options.AddKubeConfigFlag(flags, &amp;initOptions.kubeconfigPath)</span><br><span class="line">		options.AddKubeConfigDirFlag(flags, &amp;initOptions.kubeconfigDir)</span><br><span class="line">		options.AddControlPlanExtraArgsFlags(flags, &amp;initOptions.externalClusterCfg.APIServer.ExtraArgs, &amp;initOptions.externalClusterCfg.ControllerManager.ExtraArgs, &amp;initOptions.externalClusterCfg.Scheduler.ExtraArgs)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// initialize the workflow runner with the list of phases</span></span><br><span class="line">	initRunner.AppendPhase(phases.NewPreflightPhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewCertsPhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewKubeConfigPhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewEtcdPhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewControlPlanePhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewKubeletStartPhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewWaitControlPlanePhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewUploadConfigPhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewUploadCertsPhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewMarkControlPlanePhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewBootstrapTokenPhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewKubeletFinalizePhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewAddonPhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewShowJoinCommandPhase())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sets the data builder function, that will be used by the runner</span></span><br><span class="line">	<span class="comment">// both when running the entire workflow or single phases</span></span><br><span class="line">	initRunner.SetDataInitializer(<span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> (workflow.RunData, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> cmd.Flags().Lookup(options.NodeCRISocket) == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// skip CRI detection</span></span><br><span class="line">			<span class="comment">// assume that the command execution does not depend on CRISocket when --cri-socket flag is not set</span></span><br><span class="line">			initOptions.skipCRIDetect = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		data, err := newInitData(cmd, args, initOptions, out)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If the flag for skipping phases was empty, use the values from config</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(initRunner.Options.SkipPhases) == <span class="number">0</span> &#123;</span><br><span class="line">			initRunner.Options.SkipPhases = data.cfg.SkipPhases</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		initRunner.Options.SkipPhases = manageSkippedAddons(&amp;data.cfg.ClusterConfiguration, initRunner.Options.SkipPhases)</span><br><span class="line">		<span class="keyword">return</span> data, <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// binds the Runner to kubeadm init command by altering</span></span><br><span class="line">	<span class="comment">// command help, adding --skip-phases flag and by adding phases subcommands</span></span><br><span class="line">	initRunner.BindToCommand(cmd)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行kubeadm的命令</p>
<ul>
<li>phases.NewPreflightPhase()，用于对控制面节点进行预检查<ul>
<li>真正执行的方法检查的方法为runPreflight()</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPreflightPhase</span><span class="params">()</span></span> workflow.Phase &#123;</span><br><span class="line">	<span class="keyword">return</span> workflow.Phase&#123;</span><br><span class="line">		Name:<span class="string">&quot;preflight&quot;</span>,</span><br><span class="line">		Short:   <span class="string">&quot;Run pre-flight checks&quot;</span>,</span><br><span class="line">		Long:    <span class="string">&quot;Run pre-flight checks for kubeadm init.&quot;</span>,</span><br><span class="line">		Example: preflightExample,</span><br><span class="line">        <span class="comment">// 真正执行的预检查的方法</span></span><br><span class="line">		Run:     runPreflight,</span><br><span class="line">		InheritFlags: []<span class="type">string</span>&#123;</span><br><span class="line">			options.CfgPath,</span><br><span class="line">			options.ImageRepository,</span><br><span class="line">			options.NodeCRISocket,</span><br><span class="line">			options.IgnorePreflightErrors,</span><br><span class="line">			options.DryRun,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>runPreflight()<ul>
<li>RunInitNodeChecks()，对控制节点进行检查<ul>
<li>InitNodeChecks()，对控制平面的节点进行各种检查，包括cpu数，内存数，k8s版本等等</li>
<li>RunChecks()，将上述的各种检查进行实施</li>
<li>RunPullImagesCheck()，先判断cri是否运行，然后根据拉取镜像的策略，对于kubeadm所需的镜像进行拉取</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runPreflight</span><span class="params">(c workflow.RunData)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	data, ok := c.(InitData)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;preflight phase invoked with an invalid data struct&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;[preflight] Running pre-flight checks&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err := preflight.RunInitNodeChecks(utilsexec.New(), data.Cfg(), data.IgnorePreflightErrors(), <span class="literal">false</span>, <span class="literal">false</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> data.DryRun() &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;[preflight] Would pull the required images (like &#x27;kubeadm config images pull&#x27;)&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;[preflight] Pulling images required for setting up a Kubernetes cluster&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;[preflight] This might take a minute or two, depending on the speed of your internet connection&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;[preflight] You can also perform this action in beforehand using &#x27;kubeadm config images pull&#x27;&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> preflight.RunPullImagesCheck(utilsexec.New(), data.Cfg(), data.IgnorePreflightErrors())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunInitNodeChecks</span><span class="params">(execer utilsexec.Interface, cfg *kubeadmapi.InitConfiguration, ignorePreflightErrors sets.Set[<span class="type">string</span>], isSecondaryControlPlane <span class="type">bool</span>, downloadCerts <span class="type">bool</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	checks, err := InitNodeChecks(execer, cfg, ignorePreflightErrors, isSecondaryControlPlane, downloadCerts)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> RunChecks(checks, os.Stderr, ignorePreflightErrors)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitNodeChecks</span><span class="params">(execer utilsexec.Interface, cfg *kubeadmapi.InitConfiguration, ignorePreflightErrors sets.Set[<span class="type">string</span>], isSecondaryControlPlane <span class="type">bool</span>, downloadCerts <span class="type">bool</span>)</span></span> ([]Checker, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 第一个控制平面节点</span></span><br><span class="line">	<span class="keyword">if</span> !isSecondaryControlPlane &#123;</span><br><span class="line">		<span class="comment">// 检查是否是root用户权限</span></span><br><span class="line">		<span class="keyword">if</span> err := RunRootCheckOnly(ignorePreflightErrors); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 生成/etc/kubernetes/manifests/路径用来保存static pod的yaml</span></span><br><span class="line">	manifestsDir := filepath.Join(kubeadmconstants.KubernetesDir, kubeadmconstants.ManifestsSubDirName)</span><br><span class="line">    <span class="comment">// 将对于控制平面的各种预检查封装进checks，后续由RunChecks执行各种检查</span></span><br><span class="line">	checks := []Checker&#123;</span><br><span class="line">        <span class="comment">// master节点的cpu数必须大于2</span></span><br><span class="line">		NumCPUCheck&#123;NumCPU: kubeadmconstants.ControlPlaneNumCPU&#125;,</span><br><span class="line">        <span class="comment">// 实际中并未对内存数做出检查</span></span><br><span class="line">		MemCheck&#123;Mem: kubeadmconstants.ControlPlaneMem&#125;,</span><br><span class="line">        <span class="comment">// 检查kubeadm和k8s的version，k8s的version不能大于kubeadm的version</span></span><br><span class="line">		KubernetesVersionCheck&#123;KubernetesVersion: cfg.KubernetesVersion, KubeadmVersion: kubeadmversion.Get().GitVersion&#125;,</span><br><span class="line">		<span class="comment">// 检查防火墙的状态，防火墙的开启会报警告，但是仍会继续执行</span></span><br><span class="line">        FirewalldCheck&#123;ports: []<span class="type">int</span>&#123;<span class="type">int</span>(cfg.LocalAPIEndpoint.BindPort), kubeadmconstants.KubeletPort&#125;&#125;,</span><br><span class="line">        <span class="comment">// 检查服务的端口是否被占用</span></span><br><span class="line">		PortOpenCheck&#123;port: <span class="type">int</span>(cfg.LocalAPIEndpoint.BindPort)&#125;,</span><br><span class="line">		PortOpenCheck&#123;port: kubeadmconstants.KubeSchedulerPort&#125;,</span><br><span class="line">		PortOpenCheck&#123;port: kubeadmconstants.KubeControllerManagerPort&#125;,</span><br><span class="line">        <span class="comment">// 检查 /etc/kubernetes/manifests/ 文件下的路径是不是已经存在</span></span><br><span class="line">		FileAvailableCheck&#123;Path: kubeadmconstants.GetStaticPodFilepath(kubeadmconstants.KubeAPIServer, manifestsDir)&#125;,</span><br><span class="line">		FileAvailableCheck&#123;Path: kubeadmconstants.GetStaticPodFilepath(kubeadmconstants.KubeControllerManager, manifestsDir)&#125;,</span><br><span class="line">		FileAvailableCheck&#123;Path: kubeadmconstants.GetStaticPodFilepath(kubeadmconstants.KubeScheduler, manifestsDir)&#125;,</span><br><span class="line">		FileAvailableCheck&#123;Path: kubeadmconstants.GetStaticPodFilepath(kubeadmconstants.Etcd, manifestsDir)&#125;,</span><br><span class="line">        <span class="comment">// 检查http的连接是通过 直接连接还是通过代理连接</span></span><br><span class="line">		HTTPProxyCheck&#123;Proto: <span class="string">&quot;https&quot;</span>, Host: cfg.LocalAPIEndpoint.AdvertiseAddress&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// k8s在1.21后，就支持双协议栈（ipv4/ipv6），所以在配一些网络参数的时候可以配置&lt;IPv4 CIDR&gt;,&lt;IPv6 CIDR&gt;</span></span><br><span class="line">	IPV4Check := <span class="literal">false</span></span><br><span class="line">	IPV6Check := <span class="literal">false</span></span><br><span class="line">	cidrs := strings.Split(cfg.Networking.ServiceSubnet, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> _, cidr := <span class="keyword">range</span> cidrs &#123;</span><br><span class="line">		checks = <span class="built_in">append</span>(checks, HTTPProxyCIDRCheck&#123;Proto: <span class="string">&quot;https&quot;</span>, CIDR: cidr&#125;)</span><br><span class="line">		<span class="keyword">if</span> !IPV4Check &amp;&amp; netutils.IsIPv4CIDRString(cidr) &#123;</span><br><span class="line">			IPV4Check = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !IPV6Check &amp;&amp; netutils.IsIPv6CIDRString(cidr) &#123;</span><br><span class="line">			IPV6Check = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cidrs = strings.Split(cfg.Networking.PodSubnet, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> _, cidr := <span class="keyword">range</span> cidrs &#123;</span><br><span class="line">		checks = <span class="built_in">append</span>(checks, HTTPProxyCIDRCheck&#123;Proto: <span class="string">&quot;https&quot;</span>, CIDR: cidr&#125;)</span><br><span class="line">		<span class="keyword">if</span> !IPV4Check &amp;&amp; netutils.IsIPv4CIDRString(cidr) &#123;</span><br><span class="line">			IPV4Check = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !IPV6Check &amp;&amp; netutils.IsIPv6CIDRString(cidr) &#123;</span><br><span class="line">			IPV6Check = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于第一个控制平面的节点进行检查</span></span><br><span class="line">	<span class="keyword">if</span> !isSecondaryControlPlane &#123;</span><br><span class="line">        <span class="comment">// 检查crictl、crictl socket以及cri是否运行</span></span><br><span class="line">        <span class="comment">// 检查swap关没、hostname设置没、kubelet版本</span></span><br><span class="line">		checks = addCommonChecks(execer, cfg.KubernetesVersion, &amp;cfg.NodeRegistration, checks)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// netfilter 模板是否加载，用于容器网络和主机网络进行隔离，通常在/etc/sysctl.conf中有相应的设置结果</span></span><br><span class="line">		<span class="keyword">if</span> ip := netutils.ParseIPSloppy(cfg.LocalAPIEndpoint.AdvertiseAddress); ip != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> !IPV4Check &amp;&amp; netutils.IsIPv4(ip) &#123;</span><br><span class="line">				IPV4Check = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !IPV6Check &amp;&amp; netutils.IsIPv6(ip) &#123;</span><br><span class="line">				IPV6Check = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> IPV4Check &#123;</span><br><span class="line">			checks = addIPv4Checks(checks)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> IPV6Check &#123;</span><br><span class="line">			checks = addIPv6Checks(checks)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// if using an external etcd</span></span><br><span class="line">		<span class="keyword">if</span> cfg.Etcd.External != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// Check external etcd version before creating the cluster</span></span><br><span class="line">			checks = <span class="built_in">append</span>(checks, ExternalEtcdVersionCheck&#123;Etcd: cfg.Etcd&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果是同一个节点上的etcd，就只需要检查端口占用、路径存不存在的问题</span></span><br><span class="line">	<span class="keyword">if</span> cfg.Etcd.Local != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Only do etcd related checks when required to install a local etcd</span></span><br><span class="line">		checks = <span class="built_in">append</span>(checks,</span><br><span class="line">			PortOpenCheck&#123;port: kubeadmconstants.EtcdListenClientPort&#125;,</span><br><span class="line">			PortOpenCheck&#123;port: kubeadmconstants.EtcdListenPeerPort&#125;,</span><br><span class="line">			DirAvailableCheck&#123;Path: cfg.Etcd.Local.DataDir&#125;,</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果给k8s配置的是外部的etcd集群，就要对caFile、CertFile、keyFile文件进行检查，查看这些文件存不存在</span></span><br><span class="line">	<span class="keyword">if</span> cfg.Etcd.External != <span class="literal">nil</span> &amp;&amp; !(isSecondaryControlPlane &amp;&amp; downloadCerts) &#123;</span><br><span class="line">		<span class="comment">// Only check etcd certificates when using an external etcd and not joining with automatic download of certs</span></span><br><span class="line">		<span class="keyword">if</span> cfg.Etcd.External.CAFile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			checks = <span class="built_in">append</span>(checks, FileExistingCheck&#123;Path: cfg.Etcd.External.CAFile, Label: <span class="string">&quot;ExternalEtcdClientCertificates&quot;</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> cfg.Etcd.External.CertFile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			checks = <span class="built_in">append</span>(checks, FileExistingCheck&#123;Path: cfg.Etcd.External.CertFile, Label: <span class="string">&quot;ExternalEtcdClientCertificates&quot;</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> cfg.Etcd.External.KeyFile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			checks = <span class="built_in">append</span>(checks, FileExistingCheck&#123;Path: cfg.Etcd.External.KeyFile, Label: <span class="string">&quot;ExternalEtcdClientCertificates&quot;</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> checks, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xichuanliang.github.io/container.github.io/2023/11/11/sealos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/container.github.io/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/container.github.io/2023/11/11/sealos/" class="post-title-link" itemprop="url">Clusterctl gengerate</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-11 22:31:52" itemprop="dateCreated datePublished" datetime="2023-11-11T22:31:52+08:00">2023-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-28 23:39:07" itemprop="dateModified" datetime="2023-11-28T23:39:07+08:00">2023-11-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>该文只介绍clusterctl的generate命令，源码在cluster-api中。以下分析仅作参考。<br>同时，在<a target="_blank" rel="noopener" href="https://github.com/xichuanliang/yamlv1%E4%B8%AD%E6%8F%90%E5%8F%96%E4%BA%86clusterctl">https://github.com/xichuanliang/yamlv1中提取了clusterctl</a> gengerate的代码用于读取本地template文件和conf文件，初始化template<br>clusterctl generate用于根据给定的template生成对应的yaml，从而创建cluster-api所需的yaml资源，如cluster、machinedeployment、kubeadmcontrolplane等。上述资源供cluster-api生成一个k8s集群。</p>
<ul>
<li><p>clustectl中的命令都是基于cobra框架而生成的</p>
</li>
<li><p>在cobra框架中RunE代表在执行该命令的时候，执行的函数。RunE表示该命令能够返回错误信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generateClusterClusterCmd = &amp;cobra.Command&#123;</span><br><span class="line">	Use:   <span class="string">&quot;cluster NAME&quot;</span>,</span><br><span class="line">	Short: <span class="string">&quot;Generate templates for creating workload clusters&quot;</span>,</span><br><span class="line">	Long: LongDesc(<span class="string">`</span></span><br><span class="line"><span class="string">		Generate templates for creating workload clusters.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		clusterctl ships with a list of known providers; if necessary, edit</span></span><br><span class="line"><span class="string">		$XDG_CONFIG_HOME/cluster-api/clusterctl.yaml to add new provider or to customize existing ones.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		Each provider configuration links to a repository; clusterctl uses this information</span></span><br><span class="line"><span class="string">		to fetch templates when creating a new cluster.`</span>),</span><br><span class="line"></span><br><span class="line">	Example: Examples(<span class="string">`</span></span><br><span class="line"><span class="string">		# Generates a yaml file for creating workload clusters using</span></span><br><span class="line"><span class="string">		# the pre-installed infrastructure and bootstrap providers.</span></span><br><span class="line"><span class="string">		clusterctl generate cluster my-cluster</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args: func(cmd *cobra.Command, args []string) error &#123;</span></span><br><span class="line"><span class="string">		if len(args) != 1 &#123;</span></span><br><span class="line"><span class="string">			return errors.New(&quot;please specify a cluster name&quot;)</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		return nil</span></span><br><span class="line"><span class="string">	&#125;,</span></span><br><span class="line"><span class="string">	RunE: func(cmd *cobra.Command, args []string) error &#123;</span></span><br><span class="line"><span class="string">		return runGenerateClusterTemplate(cmd, args[0])</span></span><br><span class="line"><span class="string">	&#125;,</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>runGenerateClusterTemplate命令用于根据template生成一个yaml</p>
</li>
<li><p>该方法中最重要的便是GetClusterTemplate()方法，用于生成template。其中templateOptions对template做一些template初始化的选项，比如设置负载集群K8s的版本、master节点个数，负载集群的namespace等等。这些参数都将作用于template。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runGenerateClusterTemplate</span><span class="params">(cmd *cobra.Command, name <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	<span class="comment">// 用于生成configClient</span></span><br><span class="line">	c, err := client.New(ctx, cfgFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	templateOptions := client.GetClusterTemplateOptions&#123;</span><br><span class="line">		Kubeconfig:        client.Kubeconfig&#123;Path: gc.kubeconfig, Context: gc.kubeconfigContext&#125;,</span><br><span class="line">		ClusterName:       name,</span><br><span class="line">		TargetNamespace:   gc.targetNamespace,</span><br><span class="line">		KubernetesVersion: gc.kubernetesVersion,</span><br><span class="line">		ListVariablesOnly: gc.listVariables,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cmd.Flags().Changed(<span class="string">&quot;control-plane-machine-count&quot;</span>) &#123;</span><br><span class="line">		templateOptions.ControlPlaneMachineCount = &amp;gc.controlPlaneMachineCount</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> cmd.Flags().Changed(<span class="string">&quot;worker-machine-count&quot;</span>) &#123;</span><br><span class="line">		templateOptions.WorkerMachineCount = &amp;gc.workerMachineCount</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gc.url != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		templateOptions.URLSource = &amp;client.URLSourceOptions&#123;</span><br><span class="line">			URL: gc.url,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gc.configMapNamespace != <span class="string">&quot;&quot;</span> || gc.configMapName != <span class="string">&quot;&quot;</span> || gc.configMapDataKey != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		templateOptions.ConfigMapSource = &amp;client.ConfigMapSourceOptions&#123;</span><br><span class="line">			Namespace: gc.configMapNamespace,</span><br><span class="line">			Name:      gc.configMapName,</span><br><span class="line">			DataKey:   gc.configMapDataKey,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gc.infrastructureProvider != <span class="string">&quot;&quot;</span> || gc.flavor != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		templateOptions.ProviderRepositorySource = &amp;client.ProviderRepositorySourceOptions&#123;</span><br><span class="line">			InfrastructureProvider: gc.infrastructureProvider,</span><br><span class="line">			Flavor:                 gc.flavor,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	template, err := c.GetClusterTemplate(ctx, templateOptions)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> gc.listVariables &#123;</span><br><span class="line">		<span class="keyword">return</span> printVariablesOutput(template, templateOptions)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> printYamlOutput(template, gc.output)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>GetClusterTemplate()根据templateOptions初始化template</p>
</li>
<li><p>在该方法中会生成clusterClient。这是一个函数类型，最重要的是根据options构造了ClusterClientFactoryInput{options.Kubeconfig, options.YamlProcessor}结构体。其中YamlProcessor会对template进行真正的初始化。</p>
</li>
<li><p>该方法中会选择一个template源进行初始化，本文主要讲解使用固定的template文件进行初始化，即通过URL获取template源。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *clusterctlClient)</span></span> GetClusterTemplate(ctx context.Context, options GetClusterTemplateOptions) (Template, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 检查template的来源个数，template可以从provider repository、configMap、URL中获取</span></span><br><span class="line">    <span class="comment">// 如果template来源大于1是无法选择template进行初始化的</span></span><br><span class="line">	numsSource := options.numSources()</span><br><span class="line">	<span class="keyword">if</span> numsSource &gt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;invalid cluster template source: only one template can be used at time&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> numsSource == <span class="number">0</span> &#123;</span><br><span class="line">		options.ProviderRepositorySource = &amp;ProviderRepositorySourceOptions&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成clusterClient</span></span><br><span class="line">	clusterClient, err := c.clusterClientFactory(ClusterClientFactoryInput&#123;options.Kubeconfig, options.YamlProcessor&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对options中的某些字段进行校验，如果没有或不符合规则就返回错误信息</span></span><br><span class="line">	<span class="keyword">if</span> options.TargetNamespace == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := clusterClient.Proxy().CheckClusterAvailable(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;management cluster not available. Cannot auto-discover target namespace. Please specify a target namespace&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		currentNamespace, err := clusterClient.Proxy().CurrentNamespace()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> currentNamespace == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;failed to identify the current namespace. Please specify a target namespace&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		options.TargetNamespace = currentNamespace</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将参数中的某些变量注入进clusterClient的configClient中</span></span><br><span class="line">	<span class="keyword">if</span> err := c.templateOptionsToVariables(options); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 选择一个template源</span></span><br><span class="line">	<span class="keyword">if</span> options.ProviderRepositorySource != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Ensure this command only runs against management clusters with the current Cluster API contract.</span></span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span> This command tolerates also not existing cluster (Kubeconfig.Path==&quot;&quot;) or clusters not yet initialized in order to allow</span></span><br><span class="line">		<span class="comment">// users to dry-run the command and take a look at what the cluster will look like; in both scenarios, it is required</span></span><br><span class="line">		<span class="comment">// to pass provider:version given that auto-discovery can&#x27;t work without a provider inventory installed in a cluster.</span></span><br><span class="line">		<span class="keyword">if</span> options.Kubeconfig.Path != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := clusterClient.ProviderInventory().CheckCAPIContract(ctx, cluster.AllowCAPINotInstalled&#123;&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> c.getTemplateFromRepository(ctx, clusterClient, options)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> options.ConfigMapSource != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c.getTemplateFromConfigMap(ctx, clusterClient, *options.ConfigMapSource, options.TargetNamespace, options.ListVariablesOnly)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 通过URL获取template源</span></span><br><span class="line">	<span class="keyword">if</span> options.URLSource != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c.getTemplateFromURL(ctx, clusterClient, *options.URLSource, options.TargetNamespace, options.ListVariablesOnly)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;unable to read custom template. Please specify a template source&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据template源，将template读取到内存中</p>
</li>
<li><p>最重要的是初始化TemplateInput{}，然后执行repository.NewTemplate，对template进行初始化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *clusterctlClient)</span></span> getTemplateFromURL(ctx context.Context, cluster cluster.Client, source URLSourceOptions, targetNamespace <span class="type">string</span>, listVariablesOnly <span class="type">bool</span>) (Template, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> cluster.Template().GetFromURL(ctx, source.URL, targetNamespace, listVariablesOnly)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *templateClient)</span></span> GetFromURL(ctx context.Context, templateURL, targetNamespace <span class="type">string</span>, skipTemplateProcess <span class="type">bool</span>) (repository.Template, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> templateURL == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;invalid GetFromURL operation: missing templateURL value&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据URL读取template到内存中</span></span><br><span class="line">	content, err := t.getURLContent(ctx, templateURL)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;invalid GetFromURL operation&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化NewTemplate</span></span><br><span class="line">	<span class="keyword">return</span> repository.NewTemplate(repository.TemplateInput&#123;</span><br><span class="line">		RawArtifact:           content, <span class="comment">// 读取的内容</span></span><br><span class="line">		ConfigVariablesClient: t.configClient.Variables(), </span><br><span class="line">		Processor:             t.processor, <span class="comment">// 执行template的初始化</span></span><br><span class="line">		TargetNamespace:       targetNamespace, <span class="comment">// 负载集群的namespace</span></span><br><span class="line">		SkipTemplateProcess:   skipTemplateProcess, <span class="comment">// 是否不使用TemplateProcess，即不使用t.processor对模板进行处理</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没什么特别的，就是读取template</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *templateClient)</span></span> getURLContent(ctx context.Context, templateURL <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> templateURL == <span class="string">&quot;-&quot;</span> &#123;</span><br><span class="line">		b, err := io.ReadAll(os.Stdin)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;failed to read stdin&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rURL, err := url.Parse(templateURL)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;failed to parse %q&quot;</span>, templateURL)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> rURL.Scheme == <span class="string">&quot;https&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> rURL.Host == <span class="string">&quot;github.com&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> t.getGitHubFileContent(ctx, rURL)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> t.getRawURLFileContent(ctx, templateURL)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> rURL.Scheme == <span class="string">&quot;file&quot;</span> || rURL.Scheme == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.getLocalFileContent(rURL)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;unable to read content from %q. Only reading from GitHub and local file system is supported&quot;</span>, templateURL)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *templateClient)</span></span> getLocalFileContent(rURL *url.URL) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	f, err := os.Stat(rURL.Path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;failed to read file %q&quot;</span>, rURL.Path)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> f.IsDir() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;invalid path: file %q is actually a directory&quot;</span>, rURL.Path)</span><br><span class="line">	&#125;</span><br><span class="line">	content, err := os.ReadFile(rURL.Path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;failed to read file %q&quot;</span>, rURL.Path)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> content, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化template</p>
</li>
<li><p>input.Processor.GetVariables()，根据input读取到的content，提取变量到[]string中</p>
</li>
<li><p>input.Processor.GetVariableMap()，根据input读取到的content，将各个变量提取到map中</p>
</li>
<li><p>input.Processor.Process()，对模板进行初始化</p>
</li>
<li><p>utilyaml.ToUnstructured()，将读取到的yaml转化为k8s中的unstructured.Unstructured类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTemplate</span><span class="params">(input TemplateInput)</span></span> (Template, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据input读取到的content，对各个变量提取到[]string中</span></span><br><span class="line">	variables, err := input.Processor.GetVariables(input.RawArtifact)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据input读取到的content，将各个变量提取到map中</span></span><br><span class="line">	variableMap, err := input.Processor.GetVariableMap(input.RawArtifact)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果上文的SkipTemplateProcess为true，则不用提供的process方法对template进行初始化</span></span><br><span class="line">	<span class="keyword">if</span> input.SkipTemplateProcess &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;template&#123;</span><br><span class="line">			variables:       variables,</span><br><span class="line">			variableMap:     variableMap,</span><br><span class="line">			targetNamespace: input.TargetNamespace,</span><br><span class="line">		&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 对模板进行初始化</span></span><br><span class="line">	processedYaml, err := input.Processor.Process(input.RawArtifact, input.ConfigVariablesClient.Get)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将读取到的yaml转化为k8s中的unstructured.Unstructured类型</span></span><br><span class="line">	objs, err := utilyaml.ToUnstructured(processedYaml)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;failed to parse yaml&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> input.TargetNamespace != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// Ensures all the template components are deployed in the target namespace (applies only to namespaced objects)</span></span><br><span class="line">		<span class="comment">// This is required in order to ensure a cluster and all the related objects are in a single namespace, that is a requirement for</span></span><br><span class="line">		<span class="comment">// the clusterctl move operation (and also for many controller reconciliation loops).</span></span><br><span class="line">		objs, err = fixTargetNamespace(objs, input.TargetNamespace)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;failed to set the TargetNamespace in the template&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化template，其中objs中存放的就是即将在K8s中创建的资源</span></span><br><span class="line">	<span class="keyword">return</span> &amp;template&#123;</span><br><span class="line">		variables:       variables,</span><br><span class="line">		variableMap:     variableMap,</span><br><span class="line">		targetNamespace: input.TargetNamespace,</span><br><span class="line">		objs:            objs,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xichuanliang.github.io/container.github.io/2023/11/04/my-first-blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/container.github.io/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/container.github.io/2023/11/04/my-first-blog/" class="post-title-link" itemprop="url">接口型函数在http服务中的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-04 23:34:27" itemprop="dateCreated datePublished" datetime="2023-11-04T23:34:27+08:00">2023-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-05 13:29:14" itemprop="dateModified" datetime="2023-11-05T13:29:14+08:00">2023-11-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="初识HTTP服务"><a href="#初识HTTP服务" class="headerlink" title="初识HTTP服务"></a>初识HTTP服务</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func indexHandler(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">   fmt.Fprintf(w, &quot;URL.Path = %q\n&quot;, req.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">   http.HandleFunc(&quot;/&quot;, indexHandler)</span><br><span class="line">   err := http.ListenAndServe(&quot;9999&quot;, nil)</span><br><span class="line">   log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="http-HandleFunc"><a href="#http-HandleFunc" class="headerlink" title="http.HandleFunc()"></a>http.HandleFunc()</h1><p>保存路由(pattern)与处理函数(handler)之间的映射关系到ServeMux中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 注册pattern与handler之间的映射关系</span><br><span class="line">func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) &#123;</span><br><span class="line">	DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultServeMux本质是ServeMux，故DefaultServeMux.HandleFunc()实质是ServeMux.HandleFunc()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">var DefaultServeMux = &amp;defaultServeMux</span><br><span class="line">var defaultServeMux ServeMux</span><br><span class="line">type muxEntry struct &#123;</span><br><span class="line">   h       Handler</span><br><span class="line">   pattern string</span><br><span class="line">&#125;</span><br><span class="line">type ServeMux struct &#123;</span><br><span class="line">    mu    sync.RWMutex   // 读写锁</span><br><span class="line">    m     map[string]muxEntry // map,存储handler与pattern之间的映射关系</span><br><span class="line">    es    []muxEntry </span><br><span class="line">    hosts bool       </span><br><span class="line">&#125;</span><br><span class="line">func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) &#123;</span><br><span class="line">    // 如果handler为空，直接退出程序。因为每一个pattern都应该对应一个handler</span><br><span class="line">    if handler == nil &#123;</span><br><span class="line">	panic(&quot;http: nil handler&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 调用ServeMux.Handle, 并将handler类型转换为HandlerFunc。</span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br><span class="line">func (mux *ServeMux) Handle(pattern string, handler Handler) &#123;</span><br><span class="line">   // 使用了ServeMux结构体中的写锁</span><br><span class="line">   mux.mu.Lock()</span><br><span class="line">   defer mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line">   if pattern == &quot;&quot; &#123;</span><br><span class="line">      panic(&quot;http: invalid pattern&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">   if handler == nil &#123;</span><br><span class="line">      panic(&quot;http: nil handler&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">   if _, exist := mux.m[pattern]; exist &#123;</span><br><span class="line">      panic(&quot;http: multiple registrations for &quot; + pattern)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if mux.m == nil &#123;</span><br><span class="line">      mux.m = make(map[string]muxEntry)</span><br><span class="line">   &#125;</span><br><span class="line">   // 初始化一个muxEntry，并添加到map中</span><br><span class="line">   e := muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line">   mux.m[pattern] = e</span><br><span class="line">   if pattern[len(pattern)-1] == &#x27;/&#x27; &#123;</span><br><span class="line">      mux.es = appendSorted(mux.es, e)</span><br><span class="line">   &#125;</span><br><span class="line">   if pattern[0] != &#x27;/&#x27; &#123;</span><br><span class="line">      mux.hosts = true</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="http-ListenAndServe"><a href="#http-ListenAndServe" class="headerlink" title="http.ListenAndServe()"></a>http.ListenAndServe()</h1><p>1、建立tcp连接监听端口<br>2、可以自定义服务分发器(将请求的url转发到对应的handler进行处理)，如果不自定义则会有默认的服务分发器(DefaultServeMux)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">// 监听TCP网络地址addr，然后调用Serve来处理传入连接的请求</span><br><span class="line">func ListenAndServe(addr string, handler Handler) error &#123;</span><br><span class="line">   server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">   return server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line">// Server定义了运行一个HTTP服务器的参数</span><br><span class="line">type Server struct &#123;</span><br><span class="line">    Addr string // tcp连接的端口号</span><br><span class="line">    Handler Handler // 分发路由的Handler</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">func (srv *Server) ListenAndServe() error &#123;</span><br><span class="line">    ......</span><br><span class="line">    // tcp的端口号</span><br><span class="line">    addr := srv.Addr</span><br><span class="line">    if addr == &quot;&quot; &#123;</span><br><span class="line">	addr = &quot;:http&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    // 监听addr端口</span><br><span class="line">    ln, err := net.Listen(&quot;tcp&quot;, addr)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">	return err</span><br><span class="line">    &#125;</span><br><span class="line">    return srv.Serve(ln)</span><br><span class="line">&#125;</span><br><span class="line">func (srv *Server) Serve(l net.Listener) error &#123;</span><br><span class="line">   ......</span><br><span class="line">   ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">   // 无限循环接受连接，并为每一个连接开启一个goroutine进行处理</span><br><span class="line">   for &#123;</span><br><span class="line">      // 出现新的连接</span><br><span class="line">      rw, err := l.Accept()</span><br><span class="line">      if err != nil &#123;</span><br><span class="line">         select &#123;</span><br><span class="line">         case &lt;-srv.getDoneChan():</span><br><span class="line">            return ErrServerClosed</span><br><span class="line">         default:</span><br><span class="line">         &#125;</span><br><span class="line">         if ne, ok := err.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">            if tempDelay == 0 &#123;</span><br><span class="line">               tempDelay = 5 * time.Millisecond</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               tempDelay *= 2</span><br><span class="line">            &#125;</span><br><span class="line">            if max := 1 * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">               tempDelay = max</span><br><span class="line">            &#125;</span><br><span class="line">            srv.logf(&quot;http: Accept error: %v; retrying in %v&quot;, err, tempDelay)</span><br><span class="line">            time.Sleep(tempDelay)</span><br><span class="line">            continue</span><br><span class="line">         &#125;</span><br><span class="line">         return err</span><br><span class="line">      &#125;</span><br><span class="line">      connCtx := ctx</span><br><span class="line">      if cc := srv.ConnContext; cc != nil &#123;</span><br><span class="line">         connCtx = cc(connCtx, rw)</span><br><span class="line">         if connCtx == nil &#123;</span><br><span class="line">            panic(&quot;ConnContext returned nil&quot;)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      tempDelay = 0</span><br><span class="line">      // 创建新的连接</span><br><span class="line">      c := srv.newConn(rw)</span><br><span class="line">      c.setState(c.rwc, StateNew, runHooks) // before Serve can return</span><br><span class="line">      // 开启一个goroutine处理</span><br><span class="line">      go c.serve(connCtx)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">func (c *conn) serve(ctx context.Context) &#123;</span><br><span class="line">    ......</span><br><span class="line">    inFlightResponse = w</span><br><span class="line">    // 调用handler函数，将pattern分发到对应的处理函数(handleFunc)。</span><br><span class="line">    //初始化serverHandler，serverHandler实现了ServeHTTP接口</span><br><span class="line">    serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">    inFlightResponse = nil</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">type serverHandler struct &#123;</span><br><span class="line">   srv *Server</span><br><span class="line">&#125;</span><br><span class="line">func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) &#123;</span><br><span class="line">   // 取出Server的handler</span><br><span class="line">   handler := sh.srv.Handler</span><br><span class="line">   // 如果没有自定义的handler(http.ListenAndServe中的第二个参数，这个参数的作用是处理路由分发)，</span><br><span class="line">   //就使用DefaultServeMux作为默认的服务分发器，即将pattern与handler匹配起来</span><br><span class="line">   if handler == nil &#123;</span><br><span class="line">      handler = DefaultServeMux</span><br><span class="line">   &#125;</span><br><span class="line">   ......</span><br><span class="line">   // 调用handler的ServeHTTP</span><br><span class="line">   handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br><span class="line">// 由于使用了DefaultServeMux，所以handler.ServeHTTP()就是DefaultServeMux.ServeHTTP()</span><br><span class="line">// 又因为DefaultServeMux==ServeMux，所以最终调用的是ServeMux.ServeHTTP()</span><br><span class="line">func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">   if r.RequestURI == &quot;*&quot; &#123;</span><br><span class="line">      if r.ProtoAtLeast(1, 1) &#123;</span><br><span class="line">         w.Header().Set(&quot;Connection&quot;, &quot;close&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      w.WriteHeader(StatusBadRequest)</span><br><span class="line">      return</span><br><span class="line">   &#125;</span><br><span class="line">   // 根据r中的url，在map中找到handler</span><br><span class="line">   h, _ := mux.Handler(r)</span><br><span class="line">   // 调用handler.ServeHTTP()</span><br><span class="line">   h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码一直到最后，h指的是ServeMux中m的muxEntry的handler，此处的handler是http.HandleFunc()第二个参数，也就是最开始代码中的indexHandler，此处存在一个疑问，indexHandler为什么能调用ServeHTTP这个接口？此处并没有真正调用muxEntry中的handler，也就是路由过来的请求并没有被处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Handler接口中只有一个ServeHTTP方法，上述代码中调用的ServeHTTP都是实现的Handler接口</span><br><span class="line">type Handler interface &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义func(ResponseWriter, *Request)这一函数类型为HandlerFunc，也就是说只要是</span><br><span class="line">// 函数的参数是func(ResponseWriter, *Request)这种类型的都是HandlerFunc</span><br><span class="line">type HandlerFunc func(ResponseWriter, *Request)</span><br><span class="line"></span><br><span class="line">// HandlerFunc实现了ServeHTTP方法，也就是只要函数为func(ResponseWriter, *Request)</span><br><span class="line">// 此种类型的都默认实现了Handler接口，也就可以使用ServeHTTP方法。</span><br><span class="line">func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">    // HandlerFunc此种类型的函数在调用ServeHTTP时，都会调用f(w, r)</span><br><span class="line">    // 在本文表现为，indexHandler为HandlerFunc类型的函数，调用了f(w, r)，也就是调用了</span><br><span class="line">    //indexHandler(w ResponseWriter, r *Request)，即将路由过来的请求按照indexHandler()进行处理</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h2><p>定义函数为一种类型，函数实现接口的方法，可以回调函数。</p>
<h2 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h2><ul>
<li>调用http.HandleFunc()</li>
</ul>
<ol>
<li>调用DefaultServeMux 的 HandleFunc，</li>
<li>调用了 DefaultServeMux 的 Handle</li>
<li>向DefaultServeMux的map中增加对应的handler和pattern的映射关系</li>
</ol>
<ul>
<li>调用http.ListenAndServe()</li>
</ul>
<ol>
<li>初始化Server，存储监听的端口号以及设置路由规则</li>
<li>调用Server.ListenAndServe()</li>
<li>调用net.Listen()监听端口</li>
<li>开启无限循环，从队列种拿Accpet</li>
<li>对每一个Accept初始化一个连接，并开启一个goroutine</li>
<li>读取请求内容</li>
<li>判断handler是否为空，如果为空就设置handler为DefaultServeMux</li>
<li>调用handler.ServeHttp()，即根据路由规则调用处理函数</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/container.github.io/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/container.github.io/lib/anime.min.js"></script>
  <script src="/container.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/container.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/container.github.io/js/utils.js"></script>

<script src="/container.github.io/js/motion.js"></script>


<script src="/container.github.io/js/schemes/pisces.js"></script>


<script src="/container.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
