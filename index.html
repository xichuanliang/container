<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/container/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/container/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/container/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/container/images/logo.svg" color="#222">

<link rel="stylesheet" href="/container/css/main.css">


<link rel="stylesheet" href="/container/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xichuanliang.github.io","root":"/container/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://xichuanliang.github.io/container/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xichuanliang.github.io/container/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/container/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/container/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/container/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xichuanliang.github.io/container/2024/03/31/docker-%E9%95%9C%E5%83%8F%E5%AD%98%E5%82%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/container/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/container/2024/03/31/docker-%E9%95%9C%E5%83%8F%E5%AD%98%E5%82%A8/" class="post-title-link" itemprop="url">docker 镜像存储</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-31 15:16:48 / 修改时间：15:25:31" itemprop="dateCreated datePublished" datetime="2024-03-31T15:16:48+08:00">2024-03-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="docker镜像的存储"><a href="#docker镜像的存储" class="headerlink" title="docker镜像的存储"></a>docker镜像的存储</h3><ul>
<li><p>docker拉取镜像过程</p>
<p><img src="/container.github.io/images/pull-image.png"></p>
<ul>
<li>登录镜registry，使用~&#x2F;.docker&#x2F;config.json中的认证信息在registry中进行鉴权，从而拿到token。</li>
<li>向registry发出请求，获取manifest。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Accept:application/vnd.docker.distribution.manifest.v2+json&quot;</span> http:<span class="comment">//192.168.118.3:5000/v2/nginx/manifests/latest</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;schemaVersion&quot;</span>: <span class="number">2</span>,</span><br><span class="line">   <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,</span><br><span class="line">   <span class="string">&quot;config&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.container.image.v1+json&quot;</span>,</span><br><span class="line">      <span class="string">&quot;size&quot;</span>: <span class="number">7656</span>,</span><br><span class="line">      <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:605c77e624ddb75e6110f997c58876baa13f8754486b461117934b24a9dc3a85&quot;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">&quot;layers&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: <span class="number">31357624</span>,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:a2abf6c4d29d43a4bf9fbb769f524d0fb36a2edab49819c1bf3e76f409f953ea&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: <span class="number">25350007</span>,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:a9edb18cadd1336142d6567ebee31be2a03c0905eeefe26cb150de7b0fbc520b&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: <span class="number">602</span>,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:589b7251471a3d5fe4daccdddfefa02bdc32ffcba0a6d6a2768bf2c401faf115&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: <span class="number">894</span>,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:186b1aaa4aa6c480e92fbd982ee7c08037ef85114fbed73dbb62503f24c1dd7d&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: <span class="number">666</span>,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:b4df32aa5a72e2a4316aad3414508ccd907d87b4ad177abd7cbd62fa4dab2a2f&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: <span class="number">1395</span>,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:a0bcbecc962ed2552e817f45127ffb3d14be31642ef3548997f58ae054deb5b2&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>读取manifest中image config的digest，这个sha256值就是image ID，根据ID在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;image&#x2F;overlay2&#x2F;repositories.json中查看是否存在相同ID的image，如果有就不用从新下载。每一个镜像对应两个值，image ID（605c77e624ddb75e6110f997c58876baa13f8754486b461117934b24a9dc3a85）和digest（ee89b00528ff4f02f2405e4ee221743ebc3f8e8dd0bfd5c4c20a2fa2aaa7ede3）。image ID是manifest中的image config的digest值，digest是将manifest文件使用sha256计算得出的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Repositories&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;192.168.118.3:5000/nginx&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;192.168.118.3:5000/nginx:latest&quot;</span>: <span class="string">&quot;sha256:605c77e624ddb75e6110f997c58876baa13f8754486b461117934b24a9dc3a85&quot;</span>,</span><br><span class="line">        <span class="string">&quot;192.168.118.3:5000/nginx@sha256:ee89b00528ff4f02f2405e4ee221743ebc3f8e8dd0bfd5c4c20a2fa2aaa7ede3&quot;</span>: <span class="string">&quot;sha256:605c77e624ddb75e6110f997c58876baa13f8754486b461117934b24a9dc3a85&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;registry&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;registry:latest&quot;</span>: <span class="string">&quot;sha256:b8604a3fe8543c9e6afc29550de05b36cd162a97aa9b2833864ea8a5be11f3e2&quot;</span>,</span><br><span class="line">     <span class="string">&quot;registry@sha256:169211e20e2f2d5d115674681eb79d21a217b296b43374b8e39f97fcf866b375&quot;</span>: <span class="string">&quot;sha256:b8604a3fe8543c9e6afc29550de05b36cd162a97aa9b2833864ea8a5be11f3e2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果没有，向registry发出拿到image config的请求。从而获取image config文件。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Accept:application/vnd.docker.distribution.manifest.v2+json&quot;</span> http:<span class="comment">//192.168.118.3:5000/v2/nginx/blobs/sha256:605c77e624ddb75e6110f997c58876baa13f8754486b461117934b24a9dc3a85</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="string">&quot;rootfs&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;diff_ids&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;sha256:2edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sha256:e379e8aedd4d72bb4c529a4ca07a4e4d230b5a1d3f7a61bc80179e8f02421ad8&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sha256:b8d6e692a25e11b0d32c5c3dd544b71b1085ddc1fddad08e68cbd7fda7f70221&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sha256:f1db227348d0a5e0b99b15a096d930d1a69db7474a1847acbc31f05e4ef8df8c&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sha256:32ce5f6a5106cc637d09a98289782edf47c32cb082dc475dd47cbf19a4f866da&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sha256:d874fd2bc83bb3322b566df739681fbd2248c58d3369cb25908d68e7ed6040a6&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;layers&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>加入diff_ids根据一些列的算法匹配之后，发现一个镜像层都没有，则根据diff_ids中的sha256中的值取拉去对应的层。将拉下来的层进行gzip解压成xxx.tar包，并通过sha256sum计算是否和image config中的diff_id相同，如果不相同，拉去失败。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a2abf6c4d29d: Pull complete</span><br><span class="line">a9edb18cadd1: Pull complete</span><br><span class="line"><span class="number">589</span>b7251471a: Pull complete</span><br><span class="line"><span class="number">186</span>b1aaa4aa6: Pull complete</span><br><span class="line">b4df32aa5a72: Pull complete</span><br><span class="line">a0bcbecc962e: Pull complete</span><br><span class="line">Digest: sha256:ee89b00528ff4f02f2405e4ee221743ebc3f8e8dd0bfd5c4c20a2fa2aaa7ede3</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> <span class="number">192.168</span><span class="number">.118</span><span class="number">.3</span>:<span class="number">5000</span>/nginx:latest</span><br></pre></td></tr></table></figure>

<p>​		根据diff_ids中的sha256的值（diff id），拉取下来的压缩包进行sha256sum后，得到的值，发现与</p>
<p>​		docker pull拉取镜像时的值保持一致。同时，将xxx.tar.gz解压之后成xxx.tar之后，通过sha256sum算</p>
<p>​		法得出的值（digest）在本地存储的值保持一致。此时就产生了一种对应关系，diff_id与digest的对应关</p>
<p>​		系。diff_id是layer解压之后的sha256值，digest是layer未解压时的sha256的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Accept:application/vnd.docker.image.rootfs.diff.tar.gzip&quot;</span> http:<span class="comment">//192.168.118.3:5000/v2/nginx/blobs/sha256:a2abf6c4d29d43a4bf9fbb769f524d0fb36a2edab49819c1bf3e76f409f953ea -o layer1.tar.gz</span></span><br><span class="line"></span><br><span class="line">sha256sum layer1.tar.gz</span><br><span class="line">a2abf6c4d29d43a4bf9fbb769f524d0fb36a2edab49819c1bf3e76f409f953ea  layer1.tar.gz</span><br><span class="line"></span><br><span class="line">gzip -d layer1.tar.gz</span><br><span class="line">sha256sum layer1.tar</span><br><span class="line"><span class="number">2</span>edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f  layer1.tar</span><br></pre></td></tr></table></figure>

<p>​		这种对应关系存储在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;image&#x2F;overlay2&#x2F;distribution&#x2F;文件中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">├── diffid-by-digest（通过digest得到diffid）</span><br><span class="line">│   └── sha256</span><br><span class="line">│       ├── <span class="number">0</span>d96da54f60b86a4d869d44b44cfca69d71c4776b81d361bc057d6666ec0d878</span><br><span class="line">│       ├── <span class="number">186</span>b1aaa4aa6c480e92fbd982ee7c08037ef85114fbed73dbb62503f24c1dd7d</span><br><span class="line">│       ├── <span class="number">3790</span>aef225b922bc97aaba099fe762f7b115aec55a0083824b548a6a1e610719</span><br><span class="line">│       ├── <span class="number">41</span>af1b5f0f51947706ae712999cf098bef968a7799e7cb4bb2268829e62a6ab3</span><br><span class="line">│       ├── <span class="number">589</span>b7251471a3d5fe4daccdddfefa02bdc32ffcba0a6d6a2768bf2c401faf115</span><br><span class="line">│       ├── <span class="number">5</span>b27040df4a23c90c3837d926f633fb327fb3af9ac4fa5d5bc3520ad578acb10</span><br><span class="line">│       ├── <span class="number">79e9</span>f2f55bf5465a02ee6a6170e66005b20c7aa6b115af6fcd04fad706ea651a</span><br><span class="line">│       ├── <span class="number">7</span>c457f213c7634afb95a0fb2410a74b7b5bc0ba527033362c240c7a11bef4331</span><br><span class="line">│       ├── a0bcbecc962ed2552e817f45127ffb3d14be31642ef3548997f58ae054deb5b2</span><br><span class="line">│       ├── a2abf6c4d29d43a4bf9fbb769f524d0fb36a2edab49819c1bf3e76f409f953ea</span><br><span class="line">│       ├── a9edb18cadd1336142d6567ebee31be2a03c0905eeefe26cb150de7b0fbc520b</span><br><span class="line">│       ├── b4df32aa5a72e2a4316aad3414508ccd907d87b4ad177abd7cbd62fa4dab2a2f</span><br><span class="line">│       └── e2ead8259a04d39492c25c9548078200c5ec429f628dcf7b7535137954cc2df0</span><br><span class="line">└── v2metadata-by-diffid（通过diffid获得digest）</span><br><span class="line">    └── sha2565</span><br><span class="line">        ├── <span class="number">2</span>edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f</span><br><span class="line">        ├── <span class="number">32</span>ce5f6a5106cc637d09a98289782edf47c32cb082dc475dd47cbf19a4f866da</span><br><span class="line">        ├── <span class="number">548</span>a79621a426b4eb077c926eabac5a8620c454fb230640253e1b44dc7dd7562</span><br><span class="line">        ├── <span class="number">69715584</span>ec78c168981b0925dd7c50f4537bc598dcbce814db2803a10b777b5c</span><br><span class="line">        ├── aa4330046b37f18b2c8266a11687acfcb1912b3312ab6ee427668d9842672d69</span><br><span class="line">        ├── ad10b481abe790a76415269ad68a67e6baeded9586f1aa4d32b22bf60a74e492</span><br><span class="line">        ├── aeccf26589a7bdcad5bbde6d93db4ba6f26dd1fffcae9236e838f8546c2adb9b</span><br><span class="line">        ├── b8d6e692a25e11b0d32c5c3dd544b71b1085ddc1fddad08e68cbd7fda7f70221</span><br><span class="line">        ├── d874fd2bc83bb3322b566df739681fbd2248c58d3369cb25908d68e7ed6040a6</span><br><span class="line">        ├── e379e8aedd4d72bb4c529a4ca07a4e4d230b5a1d3f7a61bc80179e8f02421ad8</span><br><span class="line">        ├── f1db227348d0a5e0b99b15a096d930d1a69db7474a1847acbc31f05e4ef8df8c</span><br><span class="line">        └── f640be0d5aadac5d1376a1ad029edc6caff948d68373888e3007f1422f912fbe</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>最终将xxx.tar包解压成下载完成的layer文件。由此可见，镜像是文件的叠加，最终生成rootfs。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf layer1.tar</span><br><span class="line">rwxr-xr-x   <span class="number">2</span> root root      <span class="number">4096</span> Dec <span class="number">20</span>  <span class="number">2021</span> bin</span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root root         <span class="number">6</span> Dec <span class="number">12</span>  <span class="number">2021</span> boot</span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root root         <span class="number">6</span> Dec <span class="number">20</span>  <span class="number">2021</span> dev</span><br><span class="line">drwxr-xr-x  <span class="number">30</span> root root      <span class="number">4096</span> Dec <span class="number">20</span>  <span class="number">2021</span> etc</span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root root         <span class="number">6</span> Dec <span class="number">12</span>  <span class="number">2021</span> homer</span><br><span class="line">drwxr-xr-x   <span class="number">8</span> root root        <span class="number">96</span> Dec <span class="number">20</span>  <span class="number">2021</span> lib</span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root root        <span class="number">34</span> Dec <span class="number">20</span>  <span class="number">2021</span> lib64</span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root root         <span class="number">6</span> Dec <span class="number">20</span>  <span class="number">2021</span> media</span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root root         <span class="number">6</span> Dec <span class="number">20</span>  <span class="number">2021</span> mnt</span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root root         <span class="number">6</span> Dec <span class="number">20</span>  <span class="number">2021</span> opt</span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root root         <span class="number">6</span> Dec <span class="number">12</span>  <span class="number">2021</span> proc</span><br><span class="line">drwx------   <span class="number">2</span> root root        <span class="number">37</span> Dec <span class="number">20</span>  <span class="number">2021</span> root</span><br><span class="line">drwxr-xr-x   <span class="number">3</span> root root        <span class="number">30</span> Dec <span class="number">20</span>  <span class="number">2021</span> run</span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root root      <span class="number">4096</span> Dec <span class="number">20</span>  <span class="number">2021</span> sbin</span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root root         <span class="number">6</span> Dec <span class="number">20</span>  <span class="number">2021</span> srv</span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root root         <span class="number">6</span> Dec <span class="number">12</span>  <span class="number">2021</span> sys</span><br><span class="line">drwxrwxrwt   <span class="number">2</span> root root         <span class="number">6</span> Dec <span class="number">20</span>  <span class="number">2021</span> tmp</span><br><span class="line">drwxr-xr-x  <span class="number">11</span> root root       <span class="number">120</span> Dec <span class="number">20</span>  <span class="number">2021</span> usr</span><br><span class="line">drwxr-xr-x  <span class="number">11</span> root root       <span class="number">139</span> Dec <span class="number">20</span>  <span class="number">2021</span> <span class="keyword">var</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>那么最终这些xxx.tar包会怎么解压到哪里呢，总不可能随便解压一下。</li>
</ul>
</li>
<li><p>镜像在本地存储</p>
</li>
</ul>
<p><img src="/container.github.io/images/image.png"></p>
<p>​       在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;image&#x2F;overlay2&#x2F;layerdb中记录layer的存储信息，但并不真正的存储layer。</p>
<p>​        在该文件中，发现有一个文件目录和rootfs中的最底层的diff_id  </p>
<p>​      （2edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f）一致，且仅一个。</p>
<p>​        查阅资料可知，在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;image&#x2F;overlay2&#x2F;layerdb&#x2F;sha256中的每一个文件夹与diff_id保持一致，在</p>
<p>​       此处该id成为chainid。不过对应关系为：除最底层的diff_id与chainid保持一致外，其余层均依赖于下一层的</p>
<p>​        chainid。chainid用来连接镜像中的各个层</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── mounts</span><br><span class="line">│   └── <span class="number">9610566</span>a284373f2da4e0c596b8360e4e5854d3aa697798aac43ac081036f311</span><br><span class="line">├── sha256</span><br><span class="line">│   ├── <span class="number">02</span>b80ac2055edd757a996c3d554e6a8906fd3521e14d1227440afd5163a5f1c4</span><br><span class="line">│   ├── <span class="number">2</span>edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f</span><br><span class="line">│   ├── <span class="number">780238</span>f18c540007376dd5e904f583896a69fe620876cabc06977a3af4ba4fb5</span><br><span class="line">│   ├── <span class="number">7850</span>d382fb05e393e211067c5ca0aada2111fcbe550a90fed04d1c634bd31a14</span><br><span class="line">│   ├── b625d8e29573fa369e799ca7c5df8b7a902126d2b7cbeb390af59e4b9e1210c5</span><br><span class="line">│   ├── b92aa5824592ecb46e6d169f8e694a99150ccef01a2aabea7b9c02356cdabe7c</span><br><span class="line">└── tmp</span><br></pre></td></tr></table></figure>

<p>​		计算关系：本层chainid &#x3D; “下一层的chainID”+”本层的diff_id” | sha256sum</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">echo -n <span class="string">&quot;sha256:2edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f sha256:e379e8aedd4d72bb4c529a4ca07a4e4d230b5a1d3f7a61bc80179e8f02421ad8&quot;</span> | sha256sum</span><br><span class="line"><span class="number">780238</span>f18c540007376dd5e904f583896a69fe620876cabc06977a3af4ba4fb5  -</span><br><span class="line"></span><br><span class="line">echo -n <span class="string">&quot;sha256:780238f18c540007376dd5e904f583896a69fe620876cabc06977a3af4ba4fb5 sha256:b8d6e692a25e11b0d32c5c3dd544b71b1085ddc1fddad08e68cbd7fda7f70221&quot;</span> | sha256sum</span><br><span class="line">b92aa5824592ecb46e6d169f8e694a99150ccef01a2aabea7b9c02356cdabe7c  -</span><br><span class="line"></span><br><span class="line">echo -n <span class="string">&quot;sha256:b92aa5824592ecb46e6d169f8e694a99150ccef01a2aabea7b9c02356cdabe7c sha256:f1db227348d0a5e0b99b15a096d930d1a69db7474a1847acbc31f05e4ef8df8c&quot;</span> | sha256sum</span><br><span class="line"><span class="number">02</span>b80ac2055edd757a996c3d554e6a8906fd3521e14d1227440afd5163a5f1c4  -</span><br><span class="line"></span><br><span class="line">echo -n <span class="string">&quot;sha256:02b80ac2055edd757a996c3d554e6a8906fd3521e14d1227440afd5163a5f1c4 sha256:32ce5f6a5106cc637d09a98289782edf47c32cb082dc475dd47cbf19a4f866da&quot;</span> | sha256sum</span><br><span class="line"><span class="number">7850</span>d382fb05e393e211067c5ca0aada2111fcbe550a90fed04d1c634bd31a14  -</span><br><span class="line"></span><br><span class="line">echo -n <span class="string">&quot;sha256:7850d382fb05e393e211067c5ca0aada2111fcbe550a90fed04d1c634bd31a14 sha256:d874fd2bc83bb3322b566df739681fbd2248c58d3369cb25908d68e7ed6040a6&quot;</span> | sha256sum</span><br><span class="line">b625d8e29573fa369e799ca7c5df8b7a902126d2b7cbeb390af59e4b9e1210c5  -</span><br></pre></td></tr></table></figure>

<p>​		最终，计算出最终的chainid是</p>
<p>​		b625d8e29573fa369e799ca7c5df8b7a902126d2b7cbeb390af59e4b9e1210c5，进入这个文件目录可</p>
<p>​		知</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── cache-id 真正对应的layer数据的目录</span><br><span class="line">├── diff     该层的diffid</span><br><span class="line">├── parent   上一层的chainid</span><br><span class="line">├── size     该层的大小</span><br><span class="line">└── tar-split.json.gz tar-split.json.gz，layer压缩包的split文件，通过这个文件可以还原layer的tar包，https:<span class="comment">//github.com/vbatts/tar-split</span></span><br></pre></td></tr></table></figure>

<p>​		获取cache-id中的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat cache-id</span><br><span class="line"><span class="number">3</span>f4cb9effac5ec0d172fd92f3cd932460a785bf1b938ed8bfa5913081664003a</span><br></pre></td></tr></table></figure>

<p>​		在对应的文件查找diff层。里面就是layer中真正的内容。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /<span class="keyword">var</span>/lib/docker/overlay2/<span class="number">3</span>f4cb9effac5ec0d172fd92f3cd932460a785bf1b938ed8bfa5913081664003a</span><br><span class="line"></span><br><span class="line">cat lower</span><br><span class="line">l/<span class="number">5</span>COCTCQVW7JD7RE3WW62IWN3GV:l/M4YQYVZR2O2DCI6PNMWNVEGX3H:l/ZD6YRQ3T5ZXQKZXYP6MFCJD546:l/VE5FXRY5J4AEZDFLK6ILMFMU3E:l/PJT35YHDQWZPE3AEWI4BGHYSYC</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="number">0131057585</span>a4730358d8118159dba84e4343d2a99b20be8ec2935ac747774cde</span><br><span class="line">│   ├── committed</span><br><span class="line">│   ├── diff</span><br><span class="line">│   ├── link</span><br><span class="line">│   ├── lower</span><br><span class="line">│   └── work</span><br><span class="line">├── <span class="number">1662</span>b3b65aae2285418da9fdad8abd6fcaad1290a7c608b6cfe3d01ecfe16f0e</span><br><span class="line">│   ├── diff</span><br><span class="line">│   ├── link</span><br><span class="line">│   ├── lower</span><br><span class="line">│   ├── merged</span><br><span class="line">│   └── work</span><br><span class="line">├── <span class="number">1662</span>b3b65aae2285418da9fdad8abd6fcaad1290a7c608b6cfe3d01ecfe16f0e-init</span><br><span class="line">│   ├── committed</span><br><span class="line">│   ├── diff</span><br><span class="line">│   ├── link</span><br><span class="line">│   ├── lower</span><br><span class="line">│   └── work</span><br><span class="line">├── <span class="number">21147703e267</span>c0a9741afc92b6d84479b6d457636a2be5a84cb146ee4ee78640</span><br><span class="line">│   ├── committed</span><br><span class="line">│   ├── diff</span><br><span class="line">│   └── link</span><br><span class="line">├── <span class="number">3</span>f4cb9effac5ec0d172fd92f3cd932460a785bf1b938ed8bfa5913081664003a</span><br><span class="line">│   ├── diff</span><br><span class="line">│   ├── link</span><br><span class="line">│   ├── lower</span><br><span class="line">│   └── work</span><br><span class="line">├── <span class="number">76383</span>a05cead72c5aa8045be7c6dcce847621d08ca12571ed191155e09ae1146</span><br><span class="line">│   ├── committed</span><br><span class="line">│   ├── diff</span><br><span class="line">│   ├── link</span><br><span class="line">│   ├── lower</span><br><span class="line">│   └── work</span><br><span class="line">├── <span class="number">7</span>c01c7f54d97e5890f8e4dc66849d5b4fd00c70748d35b9fe81ccaf6c637be27</span><br><span class="line">│   ├── committed</span><br><span class="line">│   ├── diff</span><br><span class="line">│   └── link</span><br><span class="line">├── b53dd778c39441181d987ee1be7f4b9fdcfa15d6eea47af0a4f31d8423925819</span><br><span class="line">│   ├── committed</span><br><span class="line">│   ├── diff</span><br><span class="line">│   ├── link</span><br><span class="line">│   ├── lower</span><br><span class="line">│   └── work</span><br><span class="line">├── backingFsBlockDev</span><br><span class="line">├── c0e68f2807d39963736c5050d63a5b805dd2d7cde1be46867f9df123e7c15e12</span><br><span class="line">│   ├── committed</span><br><span class="line">│   ├── diff</span><br><span class="line">│   ├── link</span><br><span class="line">│   ├── lower</span><br><span class="line">│   └── work</span><br><span class="line">├── c5e9060bd948b0a4bfdd86754723bc5200fde4bee34d0c25a66e2a5414d2f11e</span><br><span class="line">│   ├── committed</span><br><span class="line">│   ├── diff</span><br><span class="line">│   ├── link</span><br><span class="line">│   ├── lower</span><br><span class="line">│   └── work</span><br><span class="line">├── c8389c704e9938c6b7d01425eaf98dc32074d2b5eddb82536fd6b49757427d1c</span><br><span class="line">│   ├── committed</span><br><span class="line">│   ├── diff</span><br><span class="line">│   ├── link</span><br><span class="line">│   ├── lower</span><br><span class="line">│   └── work</span><br><span class="line">├── cb4ad7aecae9ecb47e6b68b1d58a1e71a386f33cfd51d14d61ed4e3a56fccb5b</span><br><span class="line">│   ├── committed</span><br><span class="line">│   ├── diff</span><br><span class="line">│   ├── link</span><br><span class="line">│   ├── lower</span><br><span class="line">│   └── work</span><br><span class="line">├── e9b1b38b87553b7995f804f6de2cdccad1ce4e24921b7ea4e8a815fdeee8cf71</span><br><span class="line">│   ├── committed</span><br><span class="line">│   ├── diff</span><br><span class="line">│   ├── link</span><br><span class="line">│   ├── lower</span><br><span class="line">│   └── work</span><br><span class="line">└── l</span><br><span class="line">    ├── <span class="number">2</span>UJXL2KXNRPJH2MQTNOUISBQUN -&gt; ../<span class="number">1662</span>b3b65aae2285418da9fdad8abd6fcaad1290a7c608b6cfe3d01ecfe16f0e/diff</span><br><span class="line">    ├── <span class="number">5</span>COCTCQVW7JD7RE3WW62IWN3GV -&gt; ../c8389c704e9938c6b7d01425eaf98dc32074d2b5eddb82536fd6b49757427d1c/diff</span><br><span class="line">    ├── ALXHZKACOJCUZ72DJ5G5DQOQCF -&gt; ../<span class="number">76383</span>a05cead72c5aa8045be7c6dcce847621d08ca12571ed191155e09ae1146/diff</span><br><span class="line">    ├── C4NZT2GBJVSMOZ4QBG3RUI4EUH -&gt; ../cb4ad7aecae9ecb47e6b68b1d58a1e71a386f33cfd51d14d61ed4e3a56fccb5b/diff</span><br><span class="line">    ├── EJ7VTNUSQVI4FCHGV7SPZAUVZ5 -&gt; ../<span class="number">1662</span>b3b65aae2285418da9fdad8abd6fcaad1290a7c608b6cfe3d01ecfe16f0e-init/diff</span><br><span class="line">    ├── GL3YM5S5K63VTKYNUPOMCEPSFF -&gt; ../b53dd778c39441181d987ee1be7f4b9fdcfa15d6eea47af0a4f31d8423925819/diff</span><br><span class="line">    ├── GRN25DOYR7MLG5L6ROW444UWIW -&gt; ../<span class="number">0131057585</span>a4730358d8118159dba84e4343d2a99b20be8ec2935ac747774cde/diff</span><br><span class="line">    ├── M4YQYVZR2O2DCI6PNMWNVEGX3H -&gt; ../c5e9060bd948b0a4bfdd86754723bc5200fde4bee34d0c25a66e2a5414d2f11e/diff</span><br><span class="line">    ├── PJT35YHDQWZPE3AEWI4BGHYSYC -&gt; ../<span class="number">7</span>c01c7f54d97e5890f8e4dc66849d5b4fd00c70748d35b9fe81ccaf6c637be27/diff</span><br><span class="line">    ├── TBJFP5EWBIA6YHDRDUNAVUTPFA -&gt; ../<span class="number">3</span>f4cb9effac5ec0d172fd92f3cd932460a785bf1b938ed8bfa5913081664003a/diff</span><br><span class="line">    ├── VE5FXRY5J4AEZDFLK6ILMFMU3E -&gt; ../c0e68f2807d39963736c5050d63a5b805dd2d7cde1be46867f9df123e7c15e12/diff</span><br><span class="line">    ├── WD6DDEX6EHVPLTCDIU2MESMVSS -&gt; ../<span class="number">21147703e267</span>c0a9741afc92b6d84479b6d457636a2be5a84cb146ee4ee78640/diff</span><br><span class="line">    └── ZD6YRQ3T5ZXQKZXYP6MFCJD546 -&gt; ../e9b1b38b87553b7995f804f6de2cdccad1ce4e24921b7ea4e8a815fdeee8cf71/diff</span><br></pre></td></tr></table></figure>

<ul>
<li><p>镜像在容器中的使用</p>
<p><img src="/container.github.io/images/container.png"></p>
<p>运行一个镜像时，会在返回容器ID，并在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;image&#x2F;overlay2&#x2F;layerdb&#x2F;mounts&#x2F;中产生相应文件，记录容器启动所用的镜像层信息、init层信息、r&#x2F;w层信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">var</span>/lib/docker/image/overlay2/layerdb/mounts/<span class="number">9610566</span>a284373f2da4e0c596b8360e4e5854d3aa697798aac43ac081036f311</span><br><span class="line"></span><br><span class="line">├── init-id  init层的id</span><br><span class="line">│   ├── <span class="number">1662</span>b3b65aae2285418da9fdad8abd6fcaad1290a7c608b6cfe3d01ecfe16f0e-init</span><br><span class="line">├── mount-id r/w层的id</span><br><span class="line">│   ├── <span class="number">1662</span>b3b65aae2285418da9fdad8abd6fcaad1290a7c608b6cfe3d01ecfe16f0e</span><br><span class="line">└── parent   镜像层的chainid，根据chainid获取各个镜像层。</span><br><span class="line">│   ├── sha256:fd39b5678fdb70fc98ac5e6b4e7383f1b74b7f1a08bc6dd74fadadcc4beaf364</span><br></pre></td></tr></table></figure>

<p>根据parent的chainid获取镜像层。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /<span class="keyword">var</span>/lib/docker/image/overlay2/layerdb/sha256/fd39b5678fdb70fc98ac5e6b4e7383f1b74b7f1a08bc6dd74fadadcc4beaf364</span><br><span class="line"></span><br><span class="line">├── cache-id</span><br><span class="line">│   ├── b53dd778c39441181d987ee1be7f4b9fdcfa15d6eea47af0a4f31d8423925819</span><br><span class="line">├── diff</span><br><span class="line">├── parent</span><br><span class="line">├── size</span><br><span class="line">└── tar-split.json.gz</span><br></pre></td></tr></table></figure>

<p>从cache-id中查找对应的layer，根据lower中的链接获取其中的diff文件，最终组成镜像层。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd /<span class="keyword">var</span>/lib/docker/overlay2/b53dd778c39441181d987ee1be7f4b9fdcfa15d6eea47af0a4f31d8423925819</span><br><span class="line">├── committed</span><br><span class="line">├── diff</span><br><span class="line">│   └── entrypoint.sh</span><br><span class="line">├── link</span><br><span class="line">├── lower</span><br><span class="line">│   ├── b53dd778c39441181d987ee1be7f4b9fdcfa15d6eea47af0a4f31d8423925819l/</span><br><span class="line">C4NZT2GBJVSMOZ4QBG3RUI4EUH:l/GRN25DOYR7MLG5L6ROW444UWIW:l/ALXHZKACOJCUZ72DJ5G5DQOQCF:l/WD6DDEX6EHVPLTCDIU2MESMVSS</span><br><span class="line">└── work</span><br></pre></td></tr></table></figure>
</li>
<li><p>镜像在registry的存储</p>
<p><img src="/container.github.io/images/registry.png"></p>
<ul>
<li>registry在本地的挂载路径为&#x2F;usr&#x2F;local&#x2F;image_registry</li>
<li>在registry中分为两大部分，一部分是blobs文件，另一部分是repositories文件。<ul>
<li>blobs存储的是image manifest、image config、image layer（image的各个层）。当把相应image layer拉下来之后，使用docker-untar进程将data文件解压后的数据存放在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;${digest}&#x2F;diff中。</li>
<li>repositories存储的是镜像的版本信息、历史信息等等。<ul>
<li>_manifests文件是在镜像上传完成之后由registry生成的，并且该目录下的文件都是一个名为link的文本，link中的文本指向blobs中的 blob digest目录。__manifests文件下包含镜像的revision和tags信息，每一个镜像的每一个tag对应着tag名相同的目录。镜像的tag并不存储在image config中，而是以目录的形式形成镜像的tag。每一个tag文件下包含current和index目录，current中的link保存了该tag当前manifest的digests信息，index中列出了该tag历史上传的所有版本的sha256信息。revision目录中存放了该repository历史上传版本的所有sha256信息。</li>
<li>_layers存放镜像的image config、image layers的sha256的信息。</li>
<li>_uploads是个临时文件，主要用来存放push镜像过程中的文件数据，当镜像layer上传完成之后回清空该文件夹。其中data文件上传完毕后会转移到blobs目录下，根据该文件的sha256值散列存储到相应的目录下。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>镜像在registry中的存储<ul>
<li>registry中有两个文件夹，blobs和repositories。</li>
<li>blobs中存储image manifest、image config、image layers。即存储的是镜像的真正内容。</li>
<li>repositories中存储的是镜像的版本信息，tag信息等等。通过文件的link指引blob文件中真正的内容。</li>
</ul>
</li>
<li>拉取镜像<ul>
<li>获取registry的认证信息</li>
<li>发送url，url中包含了镜像名、tag。通过这个url去对应的repositories文件中查找对应的image manifest。将manifest返回回去。</li>
<li>获取到manifest之后，根据manifest中的image config对应的sha256值，去&#x2F;var&#x2F;lib&#x2F;docker&#x2F;image&#x2F;overlay2&#x2F;repositories.json中查找是否有相同的值，如果有就不用后续下载。如果没有就根据image config的sha256的值去registry中下载image config。</li>
<li>获取image config后，查看diff_ids。根据diff_ids在本地找对应的layer是否存在。</li>
<li>如果layer不存在，就根据diff_ids中的sha256值去registry中并行下载layer。</li>
<li>下载之后，进行解压（gzip），判断解压后的xxx.tar包的sha256值与image config中的sha256值是否相同，相同下载成功。</li>
<li>当所有的layer都下载完成之后，再将xxx.tar进行解压，解压到相应的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;${digest}&#x2F;diff中。</li>
</ul>
</li>
<li>推送镜像<ul>
<li>获取registry的认证信息</li>
<li>向registry中发送POST &#x2F;v2&#x2F;<name>&#x2F;blobs&#x2F;uploads&#x2F; 请求，检查registry中是否已经存在镜像的layer。</li>
<li>客户端通过URL上传layer数据，上传镜像layer分为整块上传和分块上传。</li>
<li>上传完成之后，docker向registry发送求情，告知layer已经上传完毕。</li>
<li>上传完成之后，将manifest上传上去。</li>
</ul>
</li>
<li>镜像在本地存储<ul>
<li>在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;image&#x2F;overlay2&#x2F;repositories.json中有对应的镜像名称和相应的值（image id、digest）。image ID是manifest中的image config的digest值，digest是将manifest文件使用sha256计算得出的。</li>
<li>在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;image&#x2F;overlay2&#x2F;distribution&#x2F;文件夹中有两个文件（diffid-by-digest、v2metadata-by-diffid），这两个文件中记录了diff_id和digest之间的对应关系。可根据diff_id和digest之间的关系，计算是否存在该layer以及是否下载的layer是否正确。</li>
<li>在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;image&#x2F;overlay2&#x2F;layerdb&#x2F;sha256中存放了chainid与layer之间的真正关系。通过最底层的diff_id与chainid相同，并且通过每一层的diff_id和上一层的chainid就能够计算出本层的chainid。进入对应的chaini目录中，查找对应的cache-id以获取layer真正的地方。</li>
<li>根据chainid获取每层的cache-id之后，在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2中根据cache-id的值查找对应的diff文件，diff文件中的文件夹就是xxx.tar解压之后，也就是layer真实的值。</li>
</ul>
</li>
<li>镜像在容器中<ul>
<li>镜像存储在本地，转化为了filesystem bundle</li>
<li>当启动容器时，生成一个容器ID，并在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;image&#x2F;overlay2&#x2F;layerdb&#x2F;mounts&#x2F;容器ID生成文件。</li>
<li>在该文件中有三个文件，init-id、mount-id、parent。<ul>
<li>init-id：容器的init层所在id</li>
<li>mount-id：容器的r&#x2F;w层所在id。</li>
<li>parent：容器的镜像层所在chainid。</li>
</ul>
</li>
<li>init-id和mount-id的文件在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;中</li>
<li>parent中的镜像层，是通过chainid获取镜像的每层文件。</li>
<li>最终使用overlayFS(联合挂载)技术，将lowerdir设置为image layer（parent）和init layer（init-id），将upperdir层设置为r&#x2F;w层（mount-id），workerdir设置为挂载之后的工作目录。最终联合挂载在merger目录中。</li>
<li>联合挂载技术的特点：<ul>
<li>上下合并时，上层文件覆盖下层同名文件。</li>
<li>写时复制。删除的文件是upper的，并且这个文件在lower层不存在直接删除。删除的文件来自于lower层，upper层没有对应的文件，overlayFS通过whiteout机制，屏蔽文件，并不真正删除文件。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xichuanliang.github.io/container/2024/03/23/pod-service-pod%E8%B7%AF%E7%94%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/container/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/container/2024/03/23/pod-service-pod%E8%B7%AF%E7%94%B1/" class="post-title-link" itemprop="url">pod-service-pod路由</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-23 15:52:03 / 修改时间：15:55:10" itemprop="dateCreated datePublished" datetime="2024-03-23T15:52:03+08:00">2024-03-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文讲述的是k8s中的service的路由，主要是流量从pod-&gt;service-&gt;pod。cni使用的是calico，kubeporxy的模式为ipvs，协议为IPIP。其中pod的网段为100.64.0.0&#x2F;10，service的网段为10.96.0.0&#x2F;22。</p>
<ul>
<li><p>pod-&gt;host</p>
<ul>
<li>每一个pod在创建前，会首先创建一个对应的pause进程，pause进程的作用是使得其他容器在加入pod时，能够共用一个network namespace，从而在同一个pod中container之间能够直接通信。</li>
<li>在创建pause的network namespace时，会初始化网络协议栈，路由表等等，使得pause的network namespace能够独立，像一台独立的虚拟机或者物理机一样。此时会初始化一个lo网卡。</li>
<li>cni插件会初始化对应的veth网卡，host中的veth另一端相连，从而进行通信。</li>
<li>当使用veth类型的网卡发送数据包时，host的network namespace中的对端veth会接收到这个数据包，同时，将这个数据包发送到网络协议栈（network protocol stack）进行处理。</li>
</ul>
<p><img src="/container.github.io/images/post-host.png"></p>
<ul>
<li>在pod中ping host的ip：<ul>
<li>由于ping命令只经过网络层、数据链路层。</li>
<li>容器经过pause的network namesapce对icmp报文添加ip头。ip头需要源ip地址和目的ip地址。这是显而易见的，不知道目的ip，ping命令都发不出去。</li>
<li>报文到达数据链路层，此时需要host主机中对端网卡的mac地址。</li>
<li>由于是第一次网络沟通，同时在初始化pause network namespace时，只存在非直连路由，即非本机ip的数据包，通通发往默认网关，同时将数据包中的mac地址更换为网关的mac地址进行发送。但是由于初始化的network namespace时的网关ip地址是不存在的，所以该网关其实是没有mac地址的。但是，还是会使用arp协议像所有网卡发送请求报文，以获得网关ip的mac地址。那他妈的怎么办？</li>
<li>其实网关的mac地址不重要，重要的是包如何获取对端veth网卡的mac地址。</li>
<li>那么重要的就是如果捕获这个arp请求报文，从而将对端veth的mac地址，封装到arp响应报文中？</li>
<li>答案是：proxy-arp。proxy arp技术能用特定网络上的代理设备来相应对本网络不存在的ip地址的arp查询。这个代码知道流量的目标，以自己的mac地址进行相应。在主机的&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;cali123&#x2F;proxy_arp中可以看到。</li>
<li>当Pod内的网络协议栈收到arp相应报文，获得对端veth的mac地址，就能顺利发送报文，从而进行通信。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/container.github.io/images/pod-host-ping.png"></p>
<ul>
<li><p>当包到达host的协议栈之后，该怎么走呢？（本文使用的cni为calico，kubeporxy的模式为ipvs，协议为IPIP）</p>
<ul>
<li><p>当数据包到达协议栈之后，首先去掉mac头。从而包到达ip层。</p>
</li>
<li><p>此时就他妈的关键了。这时候就涉及到iptables&#x2F;ipvs的规则。</p>
</li>
<li><p>无论是iptables还是ipvs都用到了Netfilter的规则。</p>
</li>
<li><p>netfilter</p>
<ul>
<li>当包进入network protocl stack时，就会去掉各种头，根据头的信息进行各种判断。</li>
<li>当包去掉mac头后，进入ip层。在ip层有iptables的策略或者ipvs的策略来决定包的走向。</li>
<li>入包：PREROUTING-&gt;IP IS LOCAL？-&gt;INPUT。出包：OUTPUT-&gt;POSTROUTING。转发：PREROUTING-&gt;FORWARD-&gt;POSTROUTING。</li>
<li>当包首次到达时，会先进入PREROUTING链中。</li>
<li>访问service的ip时，根据规则（任务协议、任务源ip、任何目的ip）会命中KUBE-SERVICES链。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">cali-PREROUTING  all  --  anywhere             anywhere             /* cali:6gwbT8clXdHdC1b1 */</span><br><span class="line">KUBE-SERVICES  all  --  anywhere             anywhere             /* kubernetes service portals */</span><br><span class="line">DOCKER     all  --  anywhere             anywhere             ADDRTYPE match dst-type LOCAL</span><br></pre></td></tr></table></figure>

<ul>
<li>进入KUBE-SERVECE链中，根据规则（任何协议，所有非100.64.0.0&#x2F;10的源ip地址，任意目的ip，能够匹配到KUBE-CLUSTER-IP集合的源ip地址）命中KUBE-MARK-MASQ链表。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-SERVICES (2 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">RETURN     all  --  loopback/8           anywhere</span><br><span class="line">KUBE-MARK-MASQ  all  -- !100.64.0.0/10        anywhere             /* Kubernetes service cluster ip + port for masquerade purpose */ match-set KUBE-CLUSTER-IP dst,dst</span><br><span class="line">KUBE-NODE-PORT  all  --  anywhere             anywhere             ADDRTYPE match dst-type LOCAL</span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             match-set KUBE-CLUSTER-IP dst,dst</span><br></pre></td></tr></table></figure>

<ul>
<li>KUBE-CLUSTER-IP集合中的所有ip是所有service的Ip。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Name: KUBE-CLUSTER-IP</span><br><span class="line">Type: hash:ip,port</span><br><span class="line">Revision: 5</span><br><span class="line">Header: family inet hashsize 1024 maxelem 65536</span><br><span class="line">Size in memory: 568</span><br><span class="line">References: 3</span><br><span class="line">Number of entries: 7</span><br><span class="line">Members:</span><br><span class="line">10.96.3.214,tcp:80</span><br><span class="line">10.96.1.195,tcp:443</span><br><span class="line">10.96.0.10,tcp:9153</span><br><span class="line">10.96.0.10,udp:53</span><br><span class="line">10.96.1.125,tcp:5473</span><br><span class="line">10.96.0.10,tcp:53</span><br><span class="line">10.96.0.1,tcp:443</span><br></pre></td></tr></table></figure>

<ul>
<li>进入KUBE-MARK-MASQ中，对命中规则的包加上标记MARK or 0x4000</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-MARK-MASQ (3 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">MARK       all  --  anywhere             anywhere             MARK or 0x4000</span><br></pre></td></tr></table></figure>

<ul>
<li>随后会判断目的ip是不是在本机中，开启ipvs模式时，cni会在host network namespace中创建kube-ipvs0网卡设备，并绑定所有service的cluster ip，这时候就会判断该ip时通往本机的了。随后进入input链。</li>
<li>ipput链，input链啥都没，进入input链的原因主要是ipvs的函数在input链的hook中。此时才能进行ipvs的相关操作。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br></pre></td></tr></table></figure>

<ul>
<li>ipvs的模式有三种（NAT、TUN、DR），但是只有NAT模式下的ipvs能够进行端口的转换，所以在k8s中ipvs使用的是NAT模式，即将service的cluster ip转换为 pod的ip。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">RemoteAddress:Port           Forward Weight ActiveConn InActConn</span></span><br><span class="line">TCP  172.17.0.1:32196 rr</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">100.99.238.82:80             Masq    1      0          0</span></span><br><span class="line">TCP  192.168.118.3:32196 rr</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">100.99.238.82:80             Masq    1      0          0</span></span><br><span class="line">TCP  10.96.0.1:443 rr</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">192.168.118.3:6443           Masq    1      7          0</span></span><br><span class="line">TCP  10.96.0.10:53 rr</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">100.89.161.145:53            Masq    1      0          0</span></span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">100.89.161.148:53            Masq    1      0          0</span></span><br><span class="line">TCP  10.96.0.10:9153 rr</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">100.89.161.145:9153          Masq    1      0          0</span></span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">100.89.161.148:9153          Masq    1      0          0</span></span><br><span class="line">TCP  10.96.1.125:5473 rr</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">192.168.118.3:5473           Masq    1      0          0</span></span><br><span class="line">TCP  10.96.1.195:443 rr</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">100.89.161.144:5443          Masq    1      0          0</span></span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">100.89.161.149:5443          Masq    1      0          0</span></span><br><span class="line">TCP  10.96.3.214:80 rr</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">100.99.238.82:80             Masq    1      0          0</span></span><br><span class="line">TCP  100.89.161.128:32196 rr</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">100.99.238.82:80             Masq    1      0          0</span></span><br><span class="line">UDP  10.96.0.10:53 rr</span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">100.89.161.145:53            Masq    1      0          14</span></span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">100.89.161.148:53            Masq    1      0          15</span></span><br></pre></td></tr></table></figure>

<ul>
<li>进入POSTROUTING链，根据规则进入KUBE-POSTROUTING链后，由于在KUBE-MARK-MASQ中打过0x4000的标记，所以进入MASQUERADE链中做SNAT转换，将源ip地址转换为host的IP地址。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">cali-POSTROUTING  all  --  anywhere             anywhere             /* cali:O3lYWMrLQYEMJtB5 */</span><br><span class="line">KUBE-POSTROUTING  all  --  anywhere             anywhere             /* kubernetes postrouting rules */</span><br><span class="line">MASQUERADE  all  --  172.17.0.0/16        anywhere</span><br><span class="line"></span><br><span class="line">Chain KUBE-POSTROUTING (1 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">MASQUERADE  all  --  anywhere             anywhere             /* Kubernetes endpoints dst ip:port, source ip for solving hairpin purpose */ match-set KUBE-LOOP-BACK dst,dst,src</span><br><span class="line">RETURN     all  --  anywhere             anywhere             mark match ! 0x4000/0x4000</span><br><span class="line">MARK       all  --  anywhere             anywhere             MARK xor 0x4000</span><br><span class="line">MASQUERADE  all  --  anywhere             anywhere             /* kubernetes service traffic requiring SNAT */</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><img src="/container.github.io/images/netfilter.png"></p>
<ul>
<li><p>此时分两种情况</p>
</li>
<li><p>pod在host中，根据路由直接经过calico的网卡转发进host的pod内的network protocal stack中。</p>
</li>
<li><p>pod在另一台主机中，根据ipip协议进行操作。</p>
<ul>
<li>根据路由将包发往tunl0。</li>
<li>tunl0将源ip层的包，再封装一层host的ip头。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">default via 192.168.118.2 dev ens33 proto static metric 100</span><br><span class="line">blackhole 100.89.161.128/26 proto bird</span><br><span class="line">100.89.161.144 dev calie390562cd7a scope link</span><br><span class="line">100.89.161.145 dev calid2a2bf1daa5 scope link</span><br><span class="line">100.89.161.146 dev calib4038b4b4dd scope link</span><br><span class="line">100.89.161.148 dev cali05df44af143 scope link</span><br><span class="line">100.89.161.149 dev cali46d30cc017e scope link</span><br><span class="line">100.89.161.150 dev calie3d7af4efc7 scope link</span><br><span class="line">100.99.238.64/26 via 192.168.118.4 dev tunl0 proto bird onlink</span><br><span class="line">172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1</span><br><span class="line">192.168.118.0/24 dev ens33 proto kernel scope link src 192.168.118.3 metric 100</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/container.github.io/images/host-host.png"></p>
<ul>
<li>总结：<ul>
<li>数据包通过pod network namespace进行封装，在传输层封装端口号，在ip层封装ip地址（service的ClusterIp），在数据链路层封装首次封装的是对端veth的mac地址，从而将包发往对端网卡中。从而进入host的network protocal stack中。</li>
<li>首次进入PREROUTING链中，经过一系列的链式规则，最终将匹配KUBE-CLUSTER-IP的包打上标记。</li>
<li>由于host的network namespace中被cni插件创建了网络设备Kube-ipvs0，并且将该网络设备绑定了所有的service的ClusterIp，所以经过PREROUTING链后进入INPUT链。</li>
<li>在INPUT链中触发ipvs规则，进行DNAT，将service的ClusterIp映射到Pod的IP。此时源IP为Pod的IP，而目的IP变为经过ipvs转换过后的service的映射pod的IP。</li>
<li>进入POSTROUTING链后，到达MASQUERADE链中进行SNAT处理，将pod的源IP转换为host的IP。</li>
<li>数据包经过路由表进行下一跳路由选择。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xichuanliang.github.io/container/2024/03/03/ping-service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/container/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/container/2024/03/03/ping-service/" class="post-title-link" itemprop="url">ping service?</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-03 16:09:19" itemprop="dateCreated datePublished" datetime="2024-03-03T16:09:19+08:00">2024-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-08 20:54:35" itemprop="dateModified" datetime="2024-03-08T20:54:35+08:00">2024-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="node能否ping通service的ClusterIP？"><a href="#node能否ping通service的ClusterIP？" class="headerlink" title="node能否ping通service的ClusterIP？"></a>node能否ping通service的ClusterIP？</h2><ul>
<li>现象：</li>
</ul>
<p>​        在1.21版本的k8s集群中，在node节点能够ping通service的ClusterIP，但是在1.27版本的k8s集群中，在node节点无法ping通service的ClusterIP。</p>
<p><img src="/container.github.io/images/image-20240302225740880.png" alt="image-20240302225740880"></p>
<p><img src="/container.github.io/images/image-20240302225842963.png" alt="image-20240302225842963"></p>
<ul>
<li><p>观察：</p>
<ul>
<li>ping IP，报的错误是Destination Port Unreachable。</li>
</ul>
</li>
<li><p>上网查询可能的原因以及解决方案：</p>
<ul>
<li>原因：在k8s中，如果kube-proxy使用的是iptables，service会出现ping不同ClusterIP。在ipvs的模式下，是能够ping通ClusterIP。</li>
<li>验证结果：在两台虚拟机中，同时验证是否开启了ipvs，以及kube-proxy的模式是什么。发现，两台虚拟机都开启了ipvs，并且都是ipvs的模式。</li>
</ul>
<p><img src="/container.github.io/images/image-20240303151256063.png" alt="image-20240303151256063"></p>
<p>​																configmap for kube-proxy</p>
<p><img src="/container.github.io/images/image-20240303151423352.png" alt="image-20240303151423352"></p>
<p>​																						ipvs</p>
<ul>
<li>分析：会不会是service转发到Pod的ip:port出现问题呢？</li>
<li>过程：首先使用ipvsadm -L -n，查看ipvs是否能够负载均衡到pod的ip:port。继续查看pod的ip:port是否正常。</li>
<li>结果：ipvs存在对应的规则，以及pod是正常的，能够ping通的。</li>
</ul>
<p><img src="/container.github.io/images/image-20240303153531730.png" alt="image-20240303153531730"></p>
<p><img src="/container.github.io/images/image-20240303153614230.png" alt="image-20240303153614230"></p>
<ul>
<li>分析：以上情况说明，只能是service本身问题，或者从主机发送的icmp报文被拦截了。service本身只是一个虚拟ip，绑定在kube-ipvs0网卡中，当请求这个service的ClusterIP时，能够直接到达input链进行处理。所以service不太可能出现什么问题。那么，问题大概率是在ping命令发送的报文被拦截了。</li>
<li>过程：使用iptables -L -n -t命令查看kube-proxy和ipvs生成的链，查看包在经过内核处理的时候做了什么。</li>
<li>结果：kube-proxy创建了KUBE-IPVS-FILTER链拒绝了所有KUBE-IPVS-IPS中的IP。而KUBE-IPVS-IPS中的IP保存了所有service的ClusterIP。而在1.21版本的k8s中，并没有该KUBE-IPVS-FILTER链。</li>
</ul>
<p><img src="/container.github.io/images/image-20240303155719695.png" alt="image-20240303155719695"></p>
<p><img src="/container.github.io/images/image-20240303155830139.png" alt="image-20240303155830139"></p>
<p>​																						k8s-1.27</p>
</li>
<li><p>结论：</p>
<ul>
<li>在1.27版本的k8s中，增加了主机对service的ClusterIP的链，阻止了主机对service进行ping命令。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xichuanliang.github.io/container/2024/02/29/kubeadm-init-Finally/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/container/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/container/2024/02/29/kubeadm-init-Finally/" class="post-title-link" itemprop="url">kubeadm init (Finally)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-29 22:49:33 / 修改时间：22:50:00" itemprop="dateCreated datePublished" datetime="2024-02-29T22:49:33+08:00">2024-02-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Kubeadm-Init-finally"><a href="#Kubeadm-Init-finally" class="headerlink" title="Kubeadm Init (finally)"></a>Kubeadm Init (finally)</h2><ul>
<li>NewKubeletStartPhase：为节点写入Kubelet的配置文件，启动kubelet。<ul>
<li>kubelet的配置文件为&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;config.yaml。该函数如果发现kubelet服务的状态为inactive，执行相应的Kubeadm 命令能够重启kubelet。</li>
<li>将env变量写入&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;kubeadm-flags.env</li>
</ul>
</li>
<li>NewWaitControlPlanePhase：是在控制平面和 etcd 阶段之后运行的隐藏阶段，作用是等待控制面节点任务的执行，如果 kubelet 启动异常或者控制面节点崩溃将会停止后面的流程。<ul>
<li>任务：kubelet监视&#x2F;etc&#x2F;kubernetes&#x2F;manifest中的文件等待创建静态Pod。</li>
</ul>
</li>
<li>NewUploadConfigPhase：上传kubeadm配置和kubelet配置。<ul>
<li>主要是创建名称为kubeadm-config和kubelet-config的configmap</li>
<li>写入crisocket的信息（kubeadm.alpha.kubernetes.io&#x2F;cri-socket: unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;cri-dockerd.sock）到node资源中。</li>
</ul>
</li>
<li>NewUploadCertsPhase：上传证书。<ul>
<li>上传证书存入kubeam-certs的secret中。</li>
<li>当新的节点加入到control plane中时需要用到。</li>
</ul>
</li>
<li>NewMarkControlPlanePhase：对于master节点添加污点<ul>
<li>添加 node-role.kubernetes.io&#x2F;control-plane&#x3D;NoSchedule node.kubernetes.io&#x2F;exclude-from-external-load-balancers&#x3D;NoSchedule</li>
</ul>
</li>
<li>NewBootstrapTokenPhase：保证新节点能够加入集群中<ul>
<li>生成bootstrap token和ca证书configmap</li>
<li>创建RBAC规则，后续 node 可以通过生成的 token join加入集群。</li>
</ul>
</li>
<li>NewKubeletFinalizePhase：更换kubelet的证书<ul>
<li>在 TLS 引导后更新与 kubelet 相关的设置，其实就是将kubelet与kube-apiserver通信的kubeconfig文件中的证书替换成由kube-controller-manager签发返回的证书</li>
</ul>
</li>
<li>NewAddonPhase：通过 API安装一个 DNS 服务器 (CoreDNS) 和 kube-proxy 附加组件<ul>
<li>在kubeadm代码中已经保存了创建coreDNS的service，deployment，clusterole，ClusterRoleBinding。只需调用client-go的api就能创建coreDNS。</li>
<li>在kubeadm代码中已经保存了创建kube-proxy的service，daemonset，clusterole，ClusterRoleBinding。只需调用client-go的api就能创建kube-proxy。</li>
</ul>
</li>
<li>NewShowJoinCommandPhase：打印初始化成功的命令，同时为用户提供后续的操作指导，例如工作节点的加入等。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xichuanliang.github.io/container/2024/02/20/kubeadmInit-%E4%BA%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/container/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/container/2024/02/20/kubeadmInit-%E4%BA%94/" class="post-title-link" itemprop="url">kubeadmInit (五)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-20 21:53:17 / 修改时间：21:53:37" itemprop="dateCreated datePublished" datetime="2024-02-20T21:53:17+08:00">2024-02-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="kubeadm-Init-五"><a href="#kubeadm-Init-五" class="headerlink" title="kubeadm Init (五)"></a>kubeadm Init (五)</h2><p>创建kube-apiserver、kube-controller-manager、kube-scheduler的静态pod的yaml文件</p>
<ul>
<li>创建工作流<ul>
<li>该工作流中存在三个子工作流，分别用于创建apiserver、controller-manager、scheduler的静态pod文件</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControlPlanePhase</span><span class="params">()</span></span> workflow.Phase &#123;</span><br><span class="line">	phase := workflow.Phase&#123;</span><br><span class="line">		Name:  <span class="string">&quot;control-plane&quot;</span>,</span><br><span class="line">		Short: <span class="string">&quot;Generate all static Pod manifest files necessary to establish the control plane&quot;</span>,</span><br><span class="line">		Long:  cmdutil.MacroCommandLongDescription,</span><br><span class="line">		Phases: []workflow.Phase&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				Name:           <span class="string">&quot;all&quot;</span>,</span><br><span class="line">				Short:          <span class="string">&quot;Generate all static Pod manifest files&quot;</span>,</span><br><span class="line">				InheritFlags:   getControlPlanePhaseFlags(<span class="string">&quot;all&quot;</span>),</span><br><span class="line">				Example:        controlPlaneExample,</span><br><span class="line">				RunAllSiblings: <span class="literal">true</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">			newControlPlaneSubphase(kubeadmconstants.KubeAPIServer),</span><br><span class="line">			newControlPlaneSubphase(kubeadmconstants.KubeControllerManager),</span><br><span class="line">			newControlPlaneSubphase(kubeadmconstants.KubeScheduler),</span><br><span class="line">		&#125;,</span><br><span class="line">		Run: runControlPlanePhase,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> phase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>子工作流<ul>
<li>根据传入的参数不同，执行相应的工作流</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newControlPlaneSubphase</span><span class="params">(component <span class="type">string</span>)</span></span> workflow.Phase &#123;</span><br><span class="line">	phase := workflow.Phase&#123;</span><br><span class="line">		Name:         controlPlanePhaseProperties[component].name,</span><br><span class="line">		Short:        controlPlanePhaseProperties[component].short,</span><br><span class="line">		Run:          runControlPlaneSubphase(component),</span><br><span class="line">		InheritFlags: getControlPlanePhaseFlags(component),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> phase</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runControlPlaneSubphase</span><span class="params">(component <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(c workflow.RunData)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c workflow.RunData)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		data, ok := c.(InitData)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.New(<span class="string">&quot;control-plane phase invoked with an invalid data struct&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		cfg := data.Cfg()</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;[control-plane] Creating static Pod manifest for %q\n&quot;</span>, component)</span><br><span class="line">		<span class="keyword">return</span> controlplane.CreateStaticPodFiles(data.ManifestDir(), data.PatchesDir(), &amp;cfg.ClusterConfiguration, &amp;cfg.LocalAPIEndpoint, data.DryRun(), component)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建对应静态pod的yaml文件<ul>
<li>GetStaticPodSpecs()：获取静态的podspec，比如获得KubeAPIServer的podSpec、KubeControllerManager的podSpec以及KubeScheduler的podSpec。在这三个的podSpec文件中，主要是包含了pod内容器的启动命令、镜像名称、卷的挂载、探针等等。</li>
<li>最终将静态pod的yaml写入&#x2F;etc&#x2F;kubernetes&#x2F;manifests&#x2F;中</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateStaticPodFiles</span><span class="params">(manifestDir, patchesDir <span class="type">string</span>, cfg *kubeadmapi.ClusterConfiguration, endpoint *kubeadmapi.APIEndpoint, isDryRun <span class="type">bool</span>, componentNames ...<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// gets the StaticPodSpecs, actualized for the current ClusterConfiguration</span></span><br><span class="line">	klog.V(<span class="number">1</span>).Infoln(<span class="string">&quot;[control-plane] getting StaticPodSpecs&quot;</span>)</span><br><span class="line">	specs := GetStaticPodSpecs(cfg, endpoint, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> usersAndGroups *users.UsersAndGroups</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">if</span> features.Enabled(cfg.FeatureGates, features.RootlessControlPlane) &#123;</span><br><span class="line">		<span class="keyword">if</span> isDryRun &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;[control-plane] Would create users and groups for %+v to run as non-root\n&quot;</span>, componentNames)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			usersAndGroups, err = staticpodutil.GetUsersAndGroups()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;failed to create users and groups&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// creates required static pod specs</span></span><br><span class="line">	<span class="keyword">for</span> _, componentName := <span class="keyword">range</span> componentNames &#123;</span><br><span class="line">		<span class="comment">// retrieves the StaticPodSpec for given component</span></span><br><span class="line">		spec, exists := specs[componentName]</span><br><span class="line">		<span class="keyword">if</span> !exists &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Errorf(<span class="string">&quot;couldn&#x27;t retrieve StaticPodSpec for %q&quot;</span>, componentName)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// print all volumes that are mounted</span></span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> spec.Spec.Volumes &#123;</span><br><span class="line">			klog.V(<span class="number">2</span>).Infof(<span class="string">&quot;[control-plane] adding volume %q for component %q&quot;</span>, v.Name, componentName)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> features.Enabled(cfg.FeatureGates, features.RootlessControlPlane) &#123;</span><br><span class="line">			<span class="keyword">if</span> isDryRun &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;[control-plane] Would update static pod manifest for %q to run run as non-root\n&quot;</span>, componentName)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> usersAndGroups != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> err := staticpodutil.RunComponentAsNonRoot(componentName, &amp;spec, usersAndGroups, cfg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;failed to run component %q as non-root&quot;</span>, componentName)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// if patchesDir is defined, patch the static Pod manifest</span></span><br><span class="line">		<span class="keyword">if</span> patchesDir != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			patchedSpec, err := staticpodutil.PatchStaticPod(&amp;spec, patchesDir, os.Stdout)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;failed to patch static Pod manifest file for %q&quot;</span>, componentName)</span><br><span class="line">			&#125;</span><br><span class="line">			spec = *patchedSpec</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// writes the StaticPodSpec to disk</span></span><br><span class="line">		<span class="keyword">if</span> err := staticpodutil.WriteStaticPodToDisk(componentName, manifestDir, spec); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;failed to create static pod manifest file for %q&quot;</span>, componentName)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		klog.V(<span class="number">1</span>).Infof(<span class="string">&quot;[control-plane] wrote static Pod manifest for component %q to %q\n&quot;</span>, componentName, kubeadmconstants.GetStaticPodFilepath(componentName, manifestDir))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据配置文件生成的相应的PodSpec</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStaticPodSpecs</span><span class="params">(cfg *kubeadmapi.ClusterConfiguration, endpoint *kubeadmapi.APIEndpoint, proxyEnvs []kubeadmapi.EnvVar)</span></span> <span class="keyword">map</span>[<span class="type">string</span>]v1.Pod &#123;</span><br><span class="line">	<span class="comment">// Get the required hostpath mounts</span></span><br><span class="line">	mounts := getHostPathVolumesForTheControlPlane(cfg)</span><br><span class="line">	<span class="keyword">if</span> proxyEnvs == <span class="literal">nil</span> &#123;</span><br><span class="line">		proxyEnvs = kubeadmutil.GetProxyEnvVars()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prepare static pod specs</span></span><br><span class="line">	staticPodSpecs := <span class="keyword">map</span>[<span class="type">string</span>]v1.Pod&#123;</span><br><span class="line">		kubeadmconstants.KubeAPIServer: staticpodutil.ComponentPod(v1.Container&#123;</span><br><span class="line">			Name:            kubeadmconstants.KubeAPIServer,</span><br><span class="line">			Image:           images.GetKubernetesImage(kubeadmconstants.KubeAPIServer, cfg),</span><br><span class="line">			ImagePullPolicy: v1.PullIfNotPresent,</span><br><span class="line">			Command:         getAPIServerCommand(cfg, endpoint),</span><br><span class="line">			VolumeMounts:    staticpodutil.VolumeMountMapToSlice(mounts.GetVolumeMounts(kubeadmconstants.KubeAPIServer)),</span><br><span class="line">			LivenessProbe:   staticpodutil.LivenessProbe(staticpodutil.GetAPIServerProbeAddress(endpoint), <span class="string">&quot;/livez&quot;</span>, endpoint.BindPort, v1.URISchemeHTTPS),</span><br><span class="line">			ReadinessProbe:  staticpodutil.ReadinessProbe(staticpodutil.GetAPIServerProbeAddress(endpoint), <span class="string">&quot;/readyz&quot;</span>, endpoint.BindPort, v1.URISchemeHTTPS),</span><br><span class="line">			StartupProbe:    staticpodutil.StartupProbe(staticpodutil.GetAPIServerProbeAddress(endpoint), <span class="string">&quot;/livez&quot;</span>, endpoint.BindPort, v1.URISchemeHTTPS, cfg.APIServer.TimeoutForControlPlane),</span><br><span class="line">			Resources:       staticpodutil.ComponentResources(<span class="string">&quot;250m&quot;</span>),</span><br><span class="line">			Env:             kubeadmutil.MergeKubeadmEnvVars(proxyEnvs, cfg.APIServer.ExtraEnvs),</span><br><span class="line">		&#125;, mounts.GetVolumes(kubeadmconstants.KubeAPIServer),</span><br><span class="line">			<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;kubeadmconstants.KubeAPIServerAdvertiseAddressEndpointAnnotationKey: endpoint.String()&#125;),</span><br><span class="line">		kubeadmconstants.KubeControllerManager: staticpodutil.ComponentPod(v1.Container&#123;</span><br><span class="line">			Name:            kubeadmconstants.KubeControllerManager,</span><br><span class="line">			Image:           images.GetKubernetesImage(kubeadmconstants.KubeControllerManager, cfg),</span><br><span class="line">			ImagePullPolicy: v1.PullIfNotPresent,</span><br><span class="line">			Command:         getControllerManagerCommand(cfg),</span><br><span class="line">			VolumeMounts:    staticpodutil.VolumeMountMapToSlice(mounts.GetVolumeMounts(kubeadmconstants.KubeControllerManager)),</span><br><span class="line">			LivenessProbe:   staticpodutil.LivenessProbe(staticpodutil.GetControllerManagerProbeAddress(cfg), <span class="string">&quot;/healthz&quot;</span>, kubeadmconstants.KubeControllerManagerPort, v1.URISchemeHTTPS),</span><br><span class="line">			StartupProbe:    staticpodutil.StartupProbe(staticpodutil.GetControllerManagerProbeAddress(cfg), <span class="string">&quot;/healthz&quot;</span>, kubeadmconstants.KubeControllerManagerPort, v1.URISchemeHTTPS, cfg.APIServer.TimeoutForControlPlane),</span><br><span class="line">			Resources:       staticpodutil.ComponentResources(<span class="string">&quot;200m&quot;</span>),</span><br><span class="line">			Env:             kubeadmutil.MergeKubeadmEnvVars(proxyEnvs, cfg.ControllerManager.ExtraEnvs),</span><br><span class="line">		&#125;, mounts.GetVolumes(kubeadmconstants.KubeControllerManager), <span class="literal">nil</span>),</span><br><span class="line">		kubeadmconstants.KubeScheduler: staticpodutil.ComponentPod(v1.Container&#123;</span><br><span class="line">			Name:            kubeadmconstants.KubeScheduler,</span><br><span class="line">			Image:           images.GetKubernetesImage(kubeadmconstants.KubeScheduler, cfg),</span><br><span class="line">			ImagePullPolicy: v1.PullIfNotPresent,</span><br><span class="line">			Command:         getSchedulerCommand(cfg),</span><br><span class="line">			VolumeMounts:    staticpodutil.VolumeMountMapToSlice(mounts.GetVolumeMounts(kubeadmconstants.KubeScheduler)),</span><br><span class="line">			LivenessProbe:   staticpodutil.LivenessProbe(staticpodutil.GetSchedulerProbeAddress(cfg), <span class="string">&quot;/healthz&quot;</span>, kubeadmconstants.KubeSchedulerPort, v1.URISchemeHTTPS),</span><br><span class="line">			StartupProbe:    staticpodutil.StartupProbe(staticpodutil.GetSchedulerProbeAddress(cfg), <span class="string">&quot;/healthz&quot;</span>, kubeadmconstants.KubeSchedulerPort, v1.URISchemeHTTPS, cfg.APIServer.TimeoutForControlPlane),</span><br><span class="line">			Resources:       staticpodutil.ComponentResources(<span class="string">&quot;100m&quot;</span>),</span><br><span class="line">			Env:             kubeadmutil.MergeKubeadmEnvVars(proxyEnvs, cfg.Scheduler.ExtraEnvs),</span><br><span class="line">		&#125;, mounts.GetVolumes(kubeadmconstants.KubeScheduler), <span class="literal">nil</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> staticPodSpecs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xichuanliang.github.io/container/2024/02/18/kubeadmInit-%E5%9B%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/container/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/container/2024/02/18/kubeadmInit-%E5%9B%9B/" class="post-title-link" itemprop="url">kubeadmInit (四)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-18 20:45:52 / 修改时间：20:46:24" itemprop="dateCreated datePublished" datetime="2024-02-18T20:45:52+08:00">2024-02-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="kubeadm-Init-四"><a href="#kubeadm-Init-四" class="headerlink" title="kubeadm Init (四)"></a>kubeadm Init (四)</h2><p>对于local etcd，产生创建etcd的yaml文件</p>
<ul>
<li>创建工作流</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEtcdPhase</span><span class="params">()</span></span> workflow.Phase &#123;</span><br><span class="line">	phase := workflow.Phase&#123;</span><br><span class="line">		Name:  <span class="string">&quot;etcd&quot;</span>,</span><br><span class="line">		Short: <span class="string">&quot;Generate static Pod manifest file for local etcd&quot;</span>,</span><br><span class="line">		Long:  cmdutil.MacroCommandLongDescription,</span><br><span class="line">		Phases: []workflow.Phase&#123;</span><br><span class="line">			newEtcdLocalSubPhase(),</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> phase</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newEtcdLocalSubPhase</span><span class="params">()</span></span> workflow.Phase &#123;</span><br><span class="line">	phase := workflow.Phase&#123;</span><br><span class="line">		Name:         <span class="string">&quot;local&quot;</span>,</span><br><span class="line">		Short:        <span class="string">&quot;Generate the static Pod manifest file for a local, single-node local etcd instance&quot;</span>,</span><br><span class="line">		Example:      etcdLocalExample,</span><br><span class="line">        <span class="comment">// 此处为创建etcd的yaml文件的入口</span></span><br><span class="line">		Run:          runEtcdPhaseLocal(),</span><br><span class="line">		InheritFlags: getEtcdPhaseFlags(),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> phase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建etcd.yaml文件<ul>
<li>如果etcd与master节点为同一节点，那就创建etcd.yaml，否则跳过创建步骤</li>
<li>CreateLocalEtcdStaticPodManifestFile()：该方法创建etcd.yaml，并且写到指定路径中</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runEtcdPhaseLocal</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(c workflow.RunData)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c workflow.RunData)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		data, ok := c.(InitData)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.New(<span class="string">&quot;etcd phase invoked with an invalid data struct&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		cfg := data.Cfg()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Add etcd static pod spec only if external etcd is not configured</span></span><br><span class="line">		<span class="keyword">if</span> cfg.Etcd.External == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// creates target folder if doesn&#x27;t exist already</span></span><br><span class="line">			<span class="keyword">if</span> !data.DryRun() &#123;</span><br><span class="line">				<span class="comment">// Create the etcd data directory</span></span><br><span class="line">				<span class="keyword">if</span> err := etcdutil.CreateDataDirectory(cfg.Etcd.Local.DataDir); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;[etcd] Would ensure that %q directory is present\n&quot;</span>, cfg.Etcd.Local.DataDir)</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;[etcd] Creating static Pod manifest for local etcd in %q\n&quot;</span>, data.ManifestDir())</span><br><span class="line">			<span class="keyword">if</span> err := etcdphase.CreateLocalEtcdStaticPodManifestFile(data.ManifestDir(), data.PatchesDir(), cfg.NodeRegistration.Name, &amp;cfg.ClusterConfiguration, &amp;cfg.LocalAPIEndpoint, data.DryRun()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;error creating local etcd static pod manifest file&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			klog.V(<span class="number">1</span>).Infoln(<span class="string">&quot;[etcd] External etcd mode. Skipping the creation of a manifest for local etcd&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建etcdpodspec，设置启动命令和参数<ul>
<li>etcd中挂载两个volume，其中一个etcd-data，保存的是在内存中顺序化记录下的所有用户对节点的变更操作，以及对数据进行便捷查询的索引等等。持久化的方式使用的是WAL和快照结合的方式，在某个时间点，生成一个对当前时间点数据的快照信息，然后再将某个时间点以后的操作，通过WAL的形式，先写日志，随后进行操作，达到事务的一致性。另一个是etcd-certs，保存etcd同其他组件通信所需的证书。</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareAndWriteEtcdStaticPod</span><span class="params">(manifestDir <span class="type">string</span>, patchesDir <span class="type">string</span>, cfg *kubeadmapi.ClusterConfiguration, endpoint *kubeadmapi.APIEndpoint, nodeName <span class="type">string</span>, initialCluster []etcdutil.Member, isDryRun <span class="type">bool</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// gets etcd StaticPodSpec, actualized for the current ClusterConfiguration and the new list of etcd members</span></span><br><span class="line">	spec := GetEtcdPodSpec(cfg, endpoint, nodeName, initialCluster)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> usersAndGroups *users.UsersAndGroups</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">if</span> features.Enabled(cfg.FeatureGates, features.RootlessControlPlane) &#123;</span><br><span class="line">		<span class="keyword">if</span> isDryRun &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;[etcd] Would create users and groups for %q to run as non-root\n&quot;</span>, kubeadmconstants.Etcd)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;[etcd] Would update static pod manifest for %q to run run as non-root\n&quot;</span>, kubeadmconstants.Etcd)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			usersAndGroups, err = staticpodutil.GetUsersAndGroups()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;failed to create users and groups&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// usersAndGroups is nil on non-linux.</span></span><br><span class="line">			<span class="keyword">if</span> usersAndGroups != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> err := staticpodutil.RunComponentAsNonRoot(kubeadmconstants.Etcd, &amp;spec, usersAndGroups, cfg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;failed to run component %q as non-root&quot;</span>, kubeadmconstants.Etcd)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if patchesDir is defined, patch the static Pod manifest</span></span><br><span class="line">	<span class="keyword">if</span> patchesDir != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		patchedSpec, err := staticpodutil.PatchStaticPod(&amp;spec, patchesDir, os.Stdout)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;failed to patch static Pod manifest file for %q&quot;</span>, kubeadmconstants.Etcd)</span><br><span class="line">		&#125;</span><br><span class="line">		spec = *patchedSpec</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// writes etcd StaticPod to disk</span></span><br><span class="line">	<span class="keyword">if</span> err := staticpodutil.WriteStaticPodToDisk(kubeadmconstants.Etcd, manifestDir, spec); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetEtcdPodSpec</span><span class="params">(cfg *kubeadmapi.ClusterConfiguration, endpoint *kubeadmapi.APIEndpoint, nodeName <span class="type">string</span>, initialCluster []etcdutil.Member)</span></span> v1.Pod &#123;</span><br><span class="line">	pathType := v1.HostPathDirectoryOrCreate</span><br><span class="line">	etcdMounts := <span class="keyword">map</span>[<span class="type">string</span>]v1.Volume&#123;</span><br><span class="line">		etcdVolumeName:  staticpodutil.NewVolume(etcdVolumeName, cfg.Etcd.Local.DataDir, &amp;pathType),</span><br><span class="line">		certsVolumeName: staticpodutil.NewVolume(certsVolumeName, cfg.CertificatesDir+<span class="string">&quot;/etcd&quot;</span>, &amp;pathType),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// probeHostname returns the correct localhost IP address family based on the endpoint AdvertiseAddress</span></span><br><span class="line">	probeHostname, probePort, probeScheme := staticpodutil.GetEtcdProbeEndpoint(&amp;cfg.Etcd, utilsnet.IsIPv6String(endpoint.AdvertiseAddress))</span><br><span class="line">	<span class="keyword">return</span> staticpodutil.ComponentPod(</span><br><span class="line">		v1.Container&#123;</span><br><span class="line">			Name:            kubeadmconstants.Etcd,</span><br><span class="line">			Command:         getEtcdCommand(cfg, endpoint, nodeName, initialCluster),</span><br><span class="line">			Image:           images.GetEtcdImage(cfg),</span><br><span class="line">			ImagePullPolicy: v1.PullIfNotPresent,</span><br><span class="line">			<span class="comment">// Mount the etcd datadir path read-write so etcd can store data in a more persistent manner</span></span><br><span class="line">			VolumeMounts: []v1.VolumeMount&#123;</span><br><span class="line">				staticpodutil.NewVolumeMount(etcdVolumeName, cfg.Etcd.Local.DataDir, <span class="literal">false</span>),</span><br><span class="line">				staticpodutil.NewVolumeMount(certsVolumeName, cfg.CertificatesDir+<span class="string">&quot;/etcd&quot;</span>, <span class="literal">false</span>),</span><br><span class="line">			&#125;,</span><br><span class="line">			Resources: v1.ResourceRequirements&#123;</span><br><span class="line">				Requests: v1.ResourceList&#123;</span><br><span class="line">					v1.ResourceCPU:    resource.MustParse(<span class="string">&quot;100m&quot;</span>),</span><br><span class="line">					v1.ResourceMemory: resource.MustParse(<span class="string">&quot;100Mi&quot;</span>),</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;,</span><br><span class="line">			LivenessProbe: staticpodutil.LivenessProbe(probeHostname, <span class="string">&quot;/health?exclude=NOSPACE&amp;serializable=true&quot;</span>, probePort, probeScheme),</span><br><span class="line">			StartupProbe:  staticpodutil.StartupProbe(probeHostname, <span class="string">&quot;/health?serializable=false&quot;</span>, probePort, probeScheme, cfg.APIServer.TimeoutForControlPlane),</span><br><span class="line">			Env:           kubeadmutil.MergeKubeadmEnvVars(cfg.Etcd.Local.ExtraEnvs),</span><br><span class="line">		&#125;,</span><br><span class="line">		etcdMounts,</span><br><span class="line">		<span class="comment">// etcd will listen on the advertise address of the API server, in a different port (2379)</span></span><br><span class="line">		<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;kubeadmconstants.EtcdAdvertiseClientUrlsAnnotationKey: etcdutil.GetClientURL(endpoint)&#125;,</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getEtcdCommand</span><span class="params">(cfg *kubeadmapi.ClusterConfiguration, endpoint *kubeadmapi.APIEndpoint, nodeName <span class="type">string</span>, initialCluster []etcdutil.Member)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// localhost IP family should be the same that the AdvertiseAddress</span></span><br><span class="line">	etcdLocalhostAddress := <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">	<span class="keyword">if</span> utilsnet.IsIPv6String(endpoint.AdvertiseAddress) &#123;</span><br><span class="line">		etcdLocalhostAddress = <span class="string">&quot;::1&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	defaultArguments := []kubeadmapi.Arg&#123;</span><br><span class="line">		&#123;Name: <span class="string">&quot;name&quot;</span>, Value: nodeName&#125;,</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> start using --initial-corrupt-check once the graduated flag is available,</span></span><br><span class="line">		<span class="comment">// https://github.com/kubernetes/kubeadm/issues/2676</span></span><br><span class="line">		&#123;Name: <span class="string">&quot;experimental-initial-corrupt-check&quot;</span>, Value: <span class="string">&quot;true&quot;</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;listen-client-urls&quot;</span>, Value: fmt.Sprintf(<span class="string">&quot;%s,%s&quot;</span>, etcdutil.GetClientURLByIP(etcdLocalhostAddress), etcdutil.GetClientURL(endpoint))&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;advertise-client-urls&quot;</span>, Value: etcdutil.GetClientURL(endpoint)&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;listen-peer-urls&quot;</span>, Value: etcdutil.GetPeerURL(endpoint)&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;initial-advertise-peer-urls&quot;</span>, Value: etcdutil.GetPeerURL(endpoint)&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;data-dir&quot;</span>, Value: cfg.Etcd.Local.DataDir&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;cert-file&quot;</span>, Value: filepath.Join(cfg.CertificatesDir, kubeadmconstants.EtcdServerCertName)&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;key-file&quot;</span>, Value: filepath.Join(cfg.CertificatesDir, kubeadmconstants.EtcdServerKeyName)&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;trusted-ca-file&quot;</span>, Value: filepath.Join(cfg.CertificatesDir, kubeadmconstants.EtcdCACertName)&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;client-cert-auth&quot;</span>, Value: <span class="string">&quot;true&quot;</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;peer-cert-file&quot;</span>, Value: filepath.Join(cfg.CertificatesDir, kubeadmconstants.EtcdPeerCertName)&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;peer-key-file&quot;</span>, Value: filepath.Join(cfg.CertificatesDir, kubeadmconstants.EtcdPeerKeyName)&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;peer-trusted-ca-file&quot;</span>, Value: filepath.Join(cfg.CertificatesDir, kubeadmconstants.EtcdCACertName)&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;peer-client-cert-auth&quot;</span>, Value: <span class="string">&quot;true&quot;</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;snapshot-count&quot;</span>, Value: <span class="string">&quot;10000&quot;</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;listen-metrics-urls&quot;</span>, Value: fmt.Sprintf(<span class="string">&quot;http://%s&quot;</span>, net.JoinHostPort(etcdLocalhostAddress, strconv.Itoa(kubeadmconstants.EtcdMetricsPort)))&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;experimental-watch-progress-notify-interval&quot;</span>, Value: <span class="string">&quot;5s&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(initialCluster) == <span class="number">0</span> &#123;</span><br><span class="line">		defaultArguments = kubeadmapi.SetArgValues(defaultArguments, <span class="string">&quot;initial-cluster&quot;</span>, fmt.Sprintf(<span class="string">&quot;%s=%s&quot;</span>, nodeName, etcdutil.GetPeerURL(endpoint)), <span class="number">1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// NB. the joining etcd member should be part of the initialCluster list</span></span><br><span class="line">		endpoints := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> _, member := <span class="keyword">range</span> initialCluster &#123;</span><br><span class="line">			endpoints = <span class="built_in">append</span>(endpoints, fmt.Sprintf(<span class="string">&quot;%s=%s&quot;</span>, member.Name, member.PeerURL))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		defaultArguments = kubeadmapi.SetArgValues(defaultArguments, <span class="string">&quot;initial-cluster&quot;</span>, strings.Join(endpoints, <span class="string">&quot;,&quot;</span>), <span class="number">1</span>)</span><br><span class="line">		defaultArguments = kubeadmapi.SetArgValues(defaultArguments, <span class="string">&quot;initial-cluster-state&quot;</span>, <span class="string">&quot;existing&quot;</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	command := []<span class="type">string</span>&#123;<span class="string">&quot;etcd&quot;</span>&#125;</span><br><span class="line">	command = <span class="built_in">append</span>(command, kubeadmutil.ArgumentsToCommand(defaultArguments, cfg.Etcd.Local.ExtraArgs)...)</span><br><span class="line">	<span class="keyword">return</span> command</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xichuanliang.github.io/container/2024/01/28/kubeadmInit-%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/container/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/container/2024/01/28/kubeadmInit-%E4%B8%89/" class="post-title-link" itemprop="url">kubeadmInit (三)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-28 22:31:39 / 修改时间：22:31:59" itemprop="dateCreated datePublished" datetime="2024-01-28T22:31:39+08:00">2024-01-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="kubeadm-Init-三"><a href="#kubeadm-Init-三" class="headerlink" title="kubeadm Init (三)"></a>kubeadm Init (三)</h2><p>kubeadm进入第三个阶段(phases.NewKubeConfigPhase())，即创建出master节点所需的所有的conf文件，以及kubeconfig，分别为admin.conf、controller-manager.conf、scheduler.conf、kubelet.conf。在这一阶段生成的conf文件是根据ca.crt以及ca.key生成的。</p>
<ol>
<li>创建工作流<ul>
<li>NewKubeConfigFilePhase()：根据name，构建每个子工作流，用于创建不同的config文件，比如admin.conf、kubelet.conf等等。</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewKubeConfigPhase</span><span class="params">()</span></span> workflow.Phase &#123;</span><br><span class="line">	<span class="keyword">return</span> workflow.Phase&#123;</span><br><span class="line">		Name:  <span class="string">&quot;kubeconfig&quot;</span>,</span><br><span class="line">		Short: <span class="string">&quot;Generate all kubeconfig files necessary to establish the control plane and the admin kubeconfig file&quot;</span>,</span><br><span class="line">		Long:  cmdutil.MacroCommandLongDescription,</span><br><span class="line">		Phases: []workflow.Phase&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				Name:           <span class="string">&quot;all&quot;</span>,</span><br><span class="line">				Short:          <span class="string">&quot;Generate all kubeconfig files&quot;</span>,</span><br><span class="line">				InheritFlags:   getKubeConfigPhaseFlags(<span class="string">&quot;all&quot;</span>),</span><br><span class="line">				RunAllSiblings: <span class="literal">true</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">			NewKubeConfigFilePhase(kubeadmconstants.AdminKubeConfigFileName),</span><br><span class="line">			NewKubeConfigFilePhase(kubeadmconstants.SuperAdminKubeConfigFileName),</span><br><span class="line">			NewKubeConfigFilePhase(kubeadmconstants.KubeletKubeConfigFileName),</span><br><span class="line">			NewKubeConfigFilePhase(kubeadmconstants.ControllerManagerKubeConfigFileName),</span><br><span class="line">			NewKubeConfigFilePhase(kubeadmconstants.SchedulerKubeConfigFileName),</span><br><span class="line">		&#125;,</span><br><span class="line">		Run: runKubeConfig,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根据每个子工作流，创建对应的config文件<ul>
<li>构建的子工作流中执行的Run方法，runKubeConfigFile()</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewKubeConfigFilePhase</span><span class="params">(kubeConfigFileName <span class="type">string</span>)</span></span> workflow.Phase &#123;</span><br><span class="line">	<span class="keyword">return</span> workflow.Phase&#123;</span><br><span class="line">		Name:         kubeconfigFilePhaseProperties[kubeConfigFileName].name,</span><br><span class="line">		Short:        kubeconfigFilePhaseProperties[kubeConfigFileName].short,</span><br><span class="line">		Long:         fmt.Sprintf(kubeconfigFilePhaseProperties[kubeConfigFileName].long, kubeConfigFileName),</span><br><span class="line">		Run:          runKubeConfigFile(kubeConfigFileName),</span><br><span class="line">		InheritFlags: getKubeConfigPhaseFlags(kubeConfigFileName),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行runKubeConfigFile，同证书一起创建config文件<ul>
<li>如果使用外部的ca颁发证书，直接返回</li>
<li>data.CertificateWriteDir()：将各个证书的存储路径保存到kubeadm-init.yaml中的InitConfiguration中</li>
<li>CreateKubeConfigFile()：创建所需的conf文件或者使用已经存在的</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runKubeConfigFile</span><span class="params">(kubeConfigFileName <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(workflow.RunData)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c workflow.RunData)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		data, ok := c.(InitData)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.New(<span class="string">&quot;kubeconfig phase invoked with an invalid data struct&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// if external CA mode, skip certificate authority generation</span></span><br><span class="line">		<span class="keyword">if</span> data.ExternalCA() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;[kubeconfig] External CA mode: Using user provided %s\n&quot;</span>, kubeConfigFileName)</span><br><span class="line">			<span class="comment">// If using an external CA while dryrun, copy kubeconfig files to dryrun dir for later use</span></span><br><span class="line">			<span class="keyword">if</span> data.DryRun() &#123;</span><br><span class="line">				err := kubeadmutil.CopyFile(filepath.Join(kubeadmconstants.KubernetesDir, kubeConfigFileName), filepath.Join(data.KubeConfigDir(), kubeConfigFileName))</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;could not copy %s to dry run directory %s&quot;</span>, kubeConfigFileName, data.KubeConfigDir())</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// if dryrunning, reads certificates from a temporary folder (and defer restore to the path originally specified by the user)</span></span><br><span class="line">		cfg := data.Cfg()</span><br><span class="line">		cfg.CertificatesDir = data.CertificateWriteDir()</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; cfg.CertificatesDir = data.CertificateDir() &#125;()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// creates the KubeConfig file (or use existing)</span></span><br><span class="line">		<span class="keyword">return</span> kubeconfigphase.CreateKubeConfigFile(kubeConfigFileName, data.KubeConfigDir(), data.Cfg())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建conf或者使用已经存在的conf<ul>
<li>getKubeConfigSpecs()：<ul>
<li>加载ca.crt和ca.key从对应的文件夹中，ca.crt一般保存在&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;文件中</li>
<li>验证ca.crt的有效时间，查看当前的证书是否还在有效期内，证书的有效期一般为365天</li>
<li>为master节点设置ControlPlaneEndpoint或者LocalApiEndpoint。ControlPlaneEndpoint在多master节点的时候做负载均衡，LocalApiEndpoint就是master所在节点的IP。其中如果没有显示这是ControlPlaneEndpoint时，就将LocalApiEndpoint的ip和端口作为ControlPlaneEndpoint的Ip和端口</li>
<li>初始化admin.conf、super-admin.conf、kubelet.conf、controller-manager.conf以及scheduler.conf的kubeconfigSpec。</li>
<li>将ca.crt以及ca.key保存在config文件中</li>
</ul>
</li>
<li>buildKubeConfigFromSpec()：<ul>
<li>创建新的key和crt</li>
<li>根据新的key和crt创建出conf，每个conf都是由一个基础conf构造而来的。一个基础conf(base conf)包括cluster的相关信息，cluster的name、url、ca.crt、users以及context。</li>
</ul>
</li>
<li>createKubeConfigFileIfNotExists()：<ul>
<li>获取conf路径</li>
<li>验证conf的有效性。加载conf，判断文件是否存在，如果存在，判断CA、URL是否相同。如果都相同就用存在的conf。如果conf不存在或者CA不同或者URL不同，就报错。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateKubeConfigFile</span><span class="params">(kubeConfigFileName <span class="type">string</span>, outDir <span class="type">string</span>, cfg *kubeadmapi.InitConfiguration)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	klog.V(<span class="number">1</span>).Infof(<span class="string">&quot;creating kubeconfig file for %s&quot;</span>, kubeConfigFileName)</span><br><span class="line">	<span class="keyword">return</span> createKubeConfigFiles(outDir, cfg, kubeConfigFileName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createKubeConfigFiles</span><span class="params">(outDir <span class="type">string</span>, cfg *kubeadmapi.InitConfiguration, kubeConfigFileNames ...<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// gets the KubeConfigSpecs, actualized for the current InitConfiguration</span></span><br><span class="line">	specs, err := getKubeConfigSpecs(cfg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, kubeConfigFileName := <span class="keyword">range</span> kubeConfigFileNames &#123;</span><br><span class="line">		<span class="comment">// retrieves the KubeConfigSpec for given kubeConfigFileName</span></span><br><span class="line">		spec, exists := specs[kubeConfigFileName]</span><br><span class="line">		<span class="keyword">if</span> !exists &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Errorf(<span class="string">&quot;couldn&#x27;t retrieve KubeConfigSpec for %s&quot;</span>, kubeConfigFileName)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// builds the KubeConfig object</span></span><br><span class="line">		config, err := buildKubeConfigFromSpec(spec, cfg.ClusterName, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// writes the kubeconfig to disk if it does not exist</span></span><br><span class="line">		<span class="keyword">if</span> err = createKubeConfigFileIfNotExists(outDir, kubeConfigFileName, config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>以controller-manager.conf为例<ul>
<li>certificate-authority-data：用于验证kube-apiserver服务器证书的CA根证书</li>
<li>client-certificate-data：用于访问kube-apiserver的客户端证书</li>
<li>client-key-data：客户端证书对应的私钥</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">cluster:</span></span><br><span class="line">    <span class="attr">certificate-authority-data:</span> <span class="string">LS0tLS1CRUdJTiBDRVJUSUZJQ0FXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXVElGSUNBVEUtLS0tLQo=</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">https://apiserver.cluster.local:6443</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">contexts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">context:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">kubernetes</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">system:kube-controller-manager</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:kube-controller-manager@kubernetes</span></span><br><span class="line"><span class="attr">current-context:</span> <span class="string">system:kube-controller-manager@kubernetes</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Config</span></span><br><span class="line"><span class="attr">preferences:</span> &#123;&#125;</span><br><span class="line"><span class="attr">users:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">system:kube-controller-manager</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">client-certificate-data:</span> <span class="string">LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLSXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span></span><br><span class="line">    <span class="attr">client-key-data:</span> <span class="string">LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xichuanliang.github.io/container/2024/01/24/kubeadmInit-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/container/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/container/2024/01/24/kubeadmInit-%E4%BA%8C/" class="post-title-link" itemprop="url">kubeadmInit (二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-24 21:21:43 / 修改时间：21:22:26" itemprop="dateCreated datePublished" datetime="2024-01-24T21:21:43+08:00">2024-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="kubeadm-Init-二"><a href="#kubeadm-Init-二" class="headerlink" title="kubeadm Init (二)"></a>kubeadm Init (二)</h2><p>kubeadm进入第二个阶段(phases.NewCertsPhase())，即证书生成与校验。生成一个自签名的CA证书为集群中的每一个组件进行身份识别的过程。</p>
<p>kubeadm会在初始化集群前，生成组件之间通信所需的证书，证书的保存位置默认在&#x2F;etc&#x2F;kubernetes&#x2F;pki，证书的过期时间默认为365天。在k8s中，组件之间通信是通过ssl进行通信，则需要csr(证书申请文件)、key(私钥)共同向ca申请证书，则在&#x2F;etc&#x2F;kubernetes&#x2F;pki中可以看到两种文件，xxx.crt和xxx.key，分别是私钥和申请后得到的证书。</p>
<p>kubeam可使用命令：kubeadm certs -h 查看所有的有关证书的命令，可通过kubeadm certs renew all重新生成各种证书。</p>
<ol>
<li>初始化CertsPhase()<ul>
<li>newCertSubPhases()生成各个组件所需的证书</li>
<li>runCerts</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCertsPhase</span><span class="params">()</span></span> workflow.Phase &#123;</span><br><span class="line">	<span class="keyword">return</span> workflow.Phase&#123;</span><br><span class="line">		Name:   <span class="string">&quot;certs&quot;</span>,</span><br><span class="line">		Short:  <span class="string">&quot;Certificate generation&quot;</span>,</span><br><span class="line">		Phases: newCertSubPhases(),</span><br><span class="line">		Run:    runCerts,</span><br><span class="line">		Long:   cmdutil.MacroCommandLongDescription,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化每一个组件所需的证书<ul>
<li>GetDefaultCertList()：各个组件通信所需的证书列表，包括apiserver与kubelet、apiserver与etcd等等互相通信的组件。</li>
<li>newCertSubPhase()：初始化每一个certsphase的phase，并执行runCAPhase()。</li>
<li>runCAPhase()：根据证书列表生成xxx.key和xxx.crt。</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCertSubPhases</span><span class="params">()</span></span> []workflow.Phase &#123;</span><br><span class="line">	subPhases := []workflow.Phase&#123;&#125;</span><br><span class="line">	<span class="comment">// All subphase</span></span><br><span class="line">	allPhase := workflow.Phase&#123;</span><br><span class="line">		Name:           <span class="string">&quot;all&quot;</span>,</span><br><span class="line">		Short:          <span class="string">&quot;Generate all certificates&quot;</span>,</span><br><span class="line">		InheritFlags:   getCertPhaseFlags(<span class="string">&quot;all&quot;</span>),</span><br><span class="line">		RunAllSiblings: <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	subPhases = <span class="built_in">append</span>(subPhases, allPhase)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This loop assumes that GetDefaultCertList() always returns a list of</span></span><br><span class="line">	<span class="comment">// certificate that is preceded by the CAs that sign them.</span></span><br><span class="line">	<span class="keyword">var</span> lastCACert *certsphase.KubeadmCert</span><br><span class="line">	<span class="keyword">for</span> _, cert := <span class="keyword">range</span> certsphase.GetDefaultCertList() &#123;</span><br><span class="line">		<span class="keyword">var</span> phase workflow.Phase</span><br><span class="line">		<span class="keyword">if</span> cert.CAName == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			phase = newCertSubPhase(cert, runCAPhase(cert))</span><br><span class="line">			lastCACert = cert</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			phase = newCertSubPhase(cert, runCertPhase(cert, lastCACert))</span><br><span class="line">		&#125;</span><br><span class="line">		subPhases = <span class="built_in">append</span>(subPhases, phase)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// SA creates the private/public key pair, which doesn&#x27;t use x509 at all</span></span><br><span class="line">	saPhase := workflow.Phase&#123;</span><br><span class="line">		Name:         <span class="string">&quot;sa&quot;</span>,</span><br><span class="line">		Short:        <span class="string">&quot;Generate a private key for signing service account tokens along with its public key&quot;</span>,</span><br><span class="line">		Long:         saKeyLongDesc,</span><br><span class="line">		Run:          runCertsSa,</span><br><span class="line">		InheritFlags: []<span class="type">string</span>&#123;options.CertificatesDir&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	subPhases = <span class="built_in">append</span>(subPhases, saPhase)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> subPhases</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成的证书列表，包括各个组件的证书</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDefaultCertList</span><span class="params">()</span></span> Certificates </span><br><span class="line">	<span class="keyword">return</span> Certificates&#123;</span><br><span class="line">		KubeadmCertRootCA(),</span><br><span class="line">		KubeadmCertAPIServer(),</span><br><span class="line">		KubeadmCertKubeletClient(),</span><br><span class="line">		<span class="comment">// Front Proxy certs</span></span><br><span class="line">		KubeadmCertFrontProxyCA(),</span><br><span class="line">		KubeadmCertFrontProxyClient(),</span><br><span class="line">		<span class="comment">// etcd certs</span></span><br><span class="line">		KubeadmCertEtcdCA(),</span><br><span class="line">		KubeadmCertEtcdServer(),</span><br><span class="line">		KubeadmCertEtcdPeer(),</span><br><span class="line">		KubeadmCertEtcdHealthcheck(),</span><br><span class="line">		KubeadmCertEtcdAPIClient(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xichuanliang.github.io/container/2024/01/07/kubeadmInit-%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/container/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/container/2024/01/07/kubeadmInit-%E4%B8%80/" class="post-title-link" itemprop="url">kubeadmInit (一)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-07 20:08:44 / 修改时间：20:09:37" itemprop="dateCreated datePublished" datetime="2024-01-07T20:08:44+08:00">2024-01-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="kubeadm-Init"><a href="#kubeadm-Init" class="headerlink" title="kubeadm Init"></a>kubeadm Init</h1><p>kubeadm 是一个 Kubernetes 集群引导工具，用于简化在 Linux 系统上初始化和设置 Kubernetes 控制平面节点（master节点）和工作节点（worker节点）。它的目标是降低 Kubernetes 部署的难度，使得用户可以更容易地搭建一个符合最佳实践的 Kubernetes 集群。</p>
<p>本文从源码的角度介绍kubeadm init命令，该命令用于初始化一个k8s集群节点。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.xxx.xxx \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--kubernetes-version=v1.23.0 \</span><br><span class="line">--service-cidr=10.96.0.0/12 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>

<ol>
<li><p>通过cobra框架引入kubeadm init命令</p>
<ul>
<li>通过initRunner.Run(args)命令，真正开始执行kubeadm init命令</li>
<li>AddInitConfigFlags()，添加k8s初始化的参数，比如–skip-phases&#x3D;xxx，添加另一个节点作为master节点，设置vip的ip</li>
<li>AddClusterConfigFlags()，添加k8s集群的配置，比如网络配置，k8s版本，控制平面ip，镜像仓库地址</li>
<li>AddInitOtherFlags()，添加额外的配置文件，比如kubeconfig的位置等等</li>
<li>initRunner.SetAdditionalFlags()，给api server、controll manager、scheduler添加默认的额外的配置，比如日志的路径以及其他相关信息</li>
<li>initRunner.AppendPhase()，将K8s初始化的每个步骤添加进命令中</li>
<li>initRunner.SetDataInitializer()，判断是否跳过cri的检查，是否跳过DNSPhase、ProxyPhase，以及其他的–skip-phases&#x3D;xxx指令</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCmdInit</span><span class="params">(out io.Writer, initOptions *initOptions)</span></span> *cobra.Command &#123;</span><br><span class="line">	<span class="keyword">if</span> initOptions == <span class="literal">nil</span> &#123;</span><br><span class="line">		initOptions = newInitOptions()</span><br><span class="line">	&#125;</span><br><span class="line">	initRunner := workflow.NewRunner()</span><br><span class="line"></span><br><span class="line">	cmd := &amp;cobra.Command&#123;</span><br><span class="line">		Use:   <span class="string">&quot;init&quot;</span>,</span><br><span class="line">		Short: <span class="string">&quot;Run this command in order to set up the Kubernetes control plane&quot;</span>,</span><br><span class="line">		RunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			c, err := initRunner.InitData(args)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			data := c.(*initData)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;[init] Using Kubernetes version: %s\n&quot;</span>, data.cfg.KubernetesVersion)</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> initRunner.Run(args)</span><br><span class="line">		&#125;,</span><br><span class="line">		Args: cobra.NoArgs,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// add flags to the init command.</span></span><br><span class="line">	<span class="comment">// init command local flags could be eventually inherited by the sub-commands automatically generated for phases</span></span><br><span class="line">	AddInitConfigFlags(cmd.Flags(), initOptions.externalInitCfg)</span><br><span class="line">	AddClusterConfigFlags(cmd.Flags(), initOptions.externalClusterCfg, &amp;initOptions.featureGatesString)</span><br><span class="line">	AddInitOtherFlags(cmd.Flags(), initOptions)</span><br><span class="line">	initOptions.bto.AddTokenFlag(cmd.Flags())</span><br><span class="line">	initOptions.bto.AddTTLFlag(cmd.Flags())</span><br><span class="line">	options.AddImageMetaFlags(cmd.Flags(), &amp;initOptions.externalClusterCfg.ImageRepository)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// defines additional flag that are not used by the init command but that could be eventually used</span></span><br><span class="line">	<span class="comment">// by the sub-commands automatically generated for phases</span></span><br><span class="line">	initRunner.SetAdditionalFlags(<span class="function"><span class="keyword">func</span><span class="params">(flags *flag.FlagSet)</span></span> &#123;</span><br><span class="line">		options.AddKubeConfigFlag(flags, &amp;initOptions.kubeconfigPath)</span><br><span class="line">		options.AddKubeConfigDirFlag(flags, &amp;initOptions.kubeconfigDir)</span><br><span class="line">		options.AddControlPlanExtraArgsFlags(flags, &amp;initOptions.externalClusterCfg.APIServer.ExtraArgs, &amp;initOptions.externalClusterCfg.ControllerManager.ExtraArgs, &amp;initOptions.externalClusterCfg.Scheduler.ExtraArgs)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// initialize the workflow runner with the list of phases</span></span><br><span class="line">	initRunner.AppendPhase(phases.NewPreflightPhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewCertsPhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewKubeConfigPhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewEtcdPhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewControlPlanePhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewKubeletStartPhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewWaitControlPlanePhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewUploadConfigPhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewUploadCertsPhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewMarkControlPlanePhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewBootstrapTokenPhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewKubeletFinalizePhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewAddonPhase())</span><br><span class="line">	initRunner.AppendPhase(phases.NewShowJoinCommandPhase())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sets the data builder function, that will be used by the runner</span></span><br><span class="line">	<span class="comment">// both when running the entire workflow or single phases</span></span><br><span class="line">	initRunner.SetDataInitializer(<span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> (workflow.RunData, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> cmd.Flags().Lookup(options.NodeCRISocket) == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// skip CRI detection</span></span><br><span class="line">			<span class="comment">// assume that the command execution does not depend on CRISocket when --cri-socket flag is not set</span></span><br><span class="line">			initOptions.skipCRIDetect = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		data, err := newInitData(cmd, args, initOptions, out)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If the flag for skipping phases was empty, use the values from config</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(initRunner.Options.SkipPhases) == <span class="number">0</span> &#123;</span><br><span class="line">			initRunner.Options.SkipPhases = data.cfg.SkipPhases</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		initRunner.Options.SkipPhases = manageSkippedAddons(&amp;data.cfg.ClusterConfiguration, initRunner.Options.SkipPhases)</span><br><span class="line">		<span class="keyword">return</span> data, <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// binds the Runner to kubeadm init command by altering</span></span><br><span class="line">	<span class="comment">// command help, adding --skip-phases flag and by adding phases subcommands</span></span><br><span class="line">	initRunner.BindToCommand(cmd)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行kubeadm的命令</p>
<ul>
<li>phases.NewPreflightPhase()，用于对控制面节点进行预检查<ul>
<li>真正执行的方法检查的方法为runPreflight()</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPreflightPhase</span><span class="params">()</span></span> workflow.Phase &#123;</span><br><span class="line">	<span class="keyword">return</span> workflow.Phase&#123;</span><br><span class="line">		Name:<span class="string">&quot;preflight&quot;</span>,</span><br><span class="line">		Short:   <span class="string">&quot;Run pre-flight checks&quot;</span>,</span><br><span class="line">		Long:    <span class="string">&quot;Run pre-flight checks for kubeadm init.&quot;</span>,</span><br><span class="line">		Example: preflightExample,</span><br><span class="line">        <span class="comment">// 真正执行的预检查的方法</span></span><br><span class="line">		Run:     runPreflight,</span><br><span class="line">		InheritFlags: []<span class="type">string</span>&#123;</span><br><span class="line">			options.CfgPath,</span><br><span class="line">			options.ImageRepository,</span><br><span class="line">			options.NodeCRISocket,</span><br><span class="line">			options.IgnorePreflightErrors,</span><br><span class="line">			options.DryRun,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>runPreflight()<ul>
<li>RunInitNodeChecks()，对控制节点进行检查<ul>
<li>InitNodeChecks()，对控制平面的节点进行各种检查，包括cpu数，内存数，k8s版本等等</li>
<li>RunChecks()，将上述的各种检查进行实施</li>
<li>RunPullImagesCheck()，先判断cri是否运行，然后根据拉取镜像的策略，对于kubeadm所需的镜像进行拉取</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runPreflight</span><span class="params">(c workflow.RunData)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	data, ok := c.(InitData)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;preflight phase invoked with an invalid data struct&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;[preflight] Running pre-flight checks&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err := preflight.RunInitNodeChecks(utilsexec.New(), data.Cfg(), data.IgnorePreflightErrors(), <span class="literal">false</span>, <span class="literal">false</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> data.DryRun() &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;[preflight] Would pull the required images (like &#x27;kubeadm config images pull&#x27;)&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;[preflight] Pulling images required for setting up a Kubernetes cluster&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;[preflight] This might take a minute or two, depending on the speed of your internet connection&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;[preflight] You can also perform this action in beforehand using &#x27;kubeadm config images pull&#x27;&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> preflight.RunPullImagesCheck(utilsexec.New(), data.Cfg(), data.IgnorePreflightErrors())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunInitNodeChecks</span><span class="params">(execer utilsexec.Interface, cfg *kubeadmapi.InitConfiguration, ignorePreflightErrors sets.Set[<span class="type">string</span>], isSecondaryControlPlane <span class="type">bool</span>, downloadCerts <span class="type">bool</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	checks, err := InitNodeChecks(execer, cfg, ignorePreflightErrors, isSecondaryControlPlane, downloadCerts)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> RunChecks(checks, os.Stderr, ignorePreflightErrors)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitNodeChecks</span><span class="params">(execer utilsexec.Interface, cfg *kubeadmapi.InitConfiguration, ignorePreflightErrors sets.Set[<span class="type">string</span>], isSecondaryControlPlane <span class="type">bool</span>, downloadCerts <span class="type">bool</span>)</span></span> ([]Checker, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 第一个控制平面节点</span></span><br><span class="line">	<span class="keyword">if</span> !isSecondaryControlPlane &#123;</span><br><span class="line">		<span class="comment">// 检查是否是root用户权限</span></span><br><span class="line">		<span class="keyword">if</span> err := RunRootCheckOnly(ignorePreflightErrors); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 生成/etc/kubernetes/manifests/路径用来保存static pod的yaml</span></span><br><span class="line">	manifestsDir := filepath.Join(kubeadmconstants.KubernetesDir, kubeadmconstants.ManifestsSubDirName)</span><br><span class="line">    <span class="comment">// 将对于控制平面的各种预检查封装进checks，后续由RunChecks执行各种检查</span></span><br><span class="line">	checks := []Checker&#123;</span><br><span class="line">        <span class="comment">// master节点的cpu数必须大于2</span></span><br><span class="line">		NumCPUCheck&#123;NumCPU: kubeadmconstants.ControlPlaneNumCPU&#125;,</span><br><span class="line">        <span class="comment">// 实际中并未对内存数做出检查</span></span><br><span class="line">		MemCheck&#123;Mem: kubeadmconstants.ControlPlaneMem&#125;,</span><br><span class="line">        <span class="comment">// 检查kubeadm和k8s的version，k8s的version不能大于kubeadm的version</span></span><br><span class="line">		KubernetesVersionCheck&#123;KubernetesVersion: cfg.KubernetesVersion, KubeadmVersion: kubeadmversion.Get().GitVersion&#125;,</span><br><span class="line">		<span class="comment">// 检查防火墙的状态，防火墙的开启会报警告，但是仍会继续执行</span></span><br><span class="line">        FirewalldCheck&#123;ports: []<span class="type">int</span>&#123;<span class="type">int</span>(cfg.LocalAPIEndpoint.BindPort), kubeadmconstants.KubeletPort&#125;&#125;,</span><br><span class="line">        <span class="comment">// 检查服务的端口是否被占用</span></span><br><span class="line">		PortOpenCheck&#123;port: <span class="type">int</span>(cfg.LocalAPIEndpoint.BindPort)&#125;,</span><br><span class="line">		PortOpenCheck&#123;port: kubeadmconstants.KubeSchedulerPort&#125;,</span><br><span class="line">		PortOpenCheck&#123;port: kubeadmconstants.KubeControllerManagerPort&#125;,</span><br><span class="line">        <span class="comment">// 检查 /etc/kubernetes/manifests/ 文件下的路径是不是已经存在</span></span><br><span class="line">		FileAvailableCheck&#123;Path: kubeadmconstants.GetStaticPodFilepath(kubeadmconstants.KubeAPIServer, manifestsDir)&#125;,</span><br><span class="line">		FileAvailableCheck&#123;Path: kubeadmconstants.GetStaticPodFilepath(kubeadmconstants.KubeControllerManager, manifestsDir)&#125;,</span><br><span class="line">		FileAvailableCheck&#123;Path: kubeadmconstants.GetStaticPodFilepath(kubeadmconstants.KubeScheduler, manifestsDir)&#125;,</span><br><span class="line">		FileAvailableCheck&#123;Path: kubeadmconstants.GetStaticPodFilepath(kubeadmconstants.Etcd, manifestsDir)&#125;,</span><br><span class="line">        <span class="comment">// 检查http的连接是通过 直接连接还是通过代理连接</span></span><br><span class="line">		HTTPProxyCheck&#123;Proto: <span class="string">&quot;https&quot;</span>, Host: cfg.LocalAPIEndpoint.AdvertiseAddress&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// k8s在1.21后，就支持双协议栈（ipv4/ipv6），所以在配一些网络参数的时候可以配置&lt;IPv4 CIDR&gt;,&lt;IPv6 CIDR&gt;</span></span><br><span class="line">	IPV4Check := <span class="literal">false</span></span><br><span class="line">	IPV6Check := <span class="literal">false</span></span><br><span class="line">	cidrs := strings.Split(cfg.Networking.ServiceSubnet, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> _, cidr := <span class="keyword">range</span> cidrs &#123;</span><br><span class="line">		checks = <span class="built_in">append</span>(checks, HTTPProxyCIDRCheck&#123;Proto: <span class="string">&quot;https&quot;</span>, CIDR: cidr&#125;)</span><br><span class="line">		<span class="keyword">if</span> !IPV4Check &amp;&amp; netutils.IsIPv4CIDRString(cidr) &#123;</span><br><span class="line">			IPV4Check = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !IPV6Check &amp;&amp; netutils.IsIPv6CIDRString(cidr) &#123;</span><br><span class="line">			IPV6Check = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cidrs = strings.Split(cfg.Networking.PodSubnet, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> _, cidr := <span class="keyword">range</span> cidrs &#123;</span><br><span class="line">		checks = <span class="built_in">append</span>(checks, HTTPProxyCIDRCheck&#123;Proto: <span class="string">&quot;https&quot;</span>, CIDR: cidr&#125;)</span><br><span class="line">		<span class="keyword">if</span> !IPV4Check &amp;&amp; netutils.IsIPv4CIDRString(cidr) &#123;</span><br><span class="line">			IPV4Check = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !IPV6Check &amp;&amp; netutils.IsIPv6CIDRString(cidr) &#123;</span><br><span class="line">			IPV6Check = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于第一个控制平面的节点进行检查</span></span><br><span class="line">	<span class="keyword">if</span> !isSecondaryControlPlane &#123;</span><br><span class="line">        <span class="comment">// 检查crictl、crictl socket以及cri是否运行</span></span><br><span class="line">        <span class="comment">// 检查swap关没、hostname设置没、kubelet版本</span></span><br><span class="line">		checks = addCommonChecks(execer, cfg.KubernetesVersion, &amp;cfg.NodeRegistration, checks)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// netfilter 模板是否加载，用于容器网络和主机网络进行隔离，通常在/etc/sysctl.conf中有相应的设置结果</span></span><br><span class="line">		<span class="keyword">if</span> ip := netutils.ParseIPSloppy(cfg.LocalAPIEndpoint.AdvertiseAddress); ip != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> !IPV4Check &amp;&amp; netutils.IsIPv4(ip) &#123;</span><br><span class="line">				IPV4Check = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !IPV6Check &amp;&amp; netutils.IsIPv6(ip) &#123;</span><br><span class="line">				IPV6Check = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> IPV4Check &#123;</span><br><span class="line">			checks = addIPv4Checks(checks)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> IPV6Check &#123;</span><br><span class="line">			checks = addIPv6Checks(checks)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// if using an external etcd</span></span><br><span class="line">		<span class="keyword">if</span> cfg.Etcd.External != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// Check external etcd version before creating the cluster</span></span><br><span class="line">			checks = <span class="built_in">append</span>(checks, ExternalEtcdVersionCheck&#123;Etcd: cfg.Etcd&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果是同一个节点上的etcd，就只需要检查端口占用、路径存不存在的问题</span></span><br><span class="line">	<span class="keyword">if</span> cfg.Etcd.Local != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Only do etcd related checks when required to install a local etcd</span></span><br><span class="line">		checks = <span class="built_in">append</span>(checks,</span><br><span class="line">			PortOpenCheck&#123;port: kubeadmconstants.EtcdListenClientPort&#125;,</span><br><span class="line">			PortOpenCheck&#123;port: kubeadmconstants.EtcdListenPeerPort&#125;,</span><br><span class="line">			DirAvailableCheck&#123;Path: cfg.Etcd.Local.DataDir&#125;,</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果给k8s配置的是外部的etcd集群，就要对caFile、CertFile、keyFile文件进行检查，查看这些文件存不存在</span></span><br><span class="line">	<span class="keyword">if</span> cfg.Etcd.External != <span class="literal">nil</span> &amp;&amp; !(isSecondaryControlPlane &amp;&amp; downloadCerts) &#123;</span><br><span class="line">		<span class="comment">// Only check etcd certificates when using an external etcd and not joining with automatic download of certs</span></span><br><span class="line">		<span class="keyword">if</span> cfg.Etcd.External.CAFile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			checks = <span class="built_in">append</span>(checks, FileExistingCheck&#123;Path: cfg.Etcd.External.CAFile, Label: <span class="string">&quot;ExternalEtcdClientCertificates&quot;</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> cfg.Etcd.External.CertFile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			checks = <span class="built_in">append</span>(checks, FileExistingCheck&#123;Path: cfg.Etcd.External.CertFile, Label: <span class="string">&quot;ExternalEtcdClientCertificates&quot;</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> cfg.Etcd.External.KeyFile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			checks = <span class="built_in">append</span>(checks, FileExistingCheck&#123;Path: cfg.Etcd.External.KeyFile, Label: <span class="string">&quot;ExternalEtcdClientCertificates&quot;</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> checks, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xichuanliang.github.io/container/2023/11/11/sealos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/container/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/container/2023/11/11/sealos/" class="post-title-link" itemprop="url">Clusterctl gengerate</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-11 22:31:52" itemprop="dateCreated datePublished" datetime="2023-11-11T22:31:52+08:00">2023-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-28 23:39:07" itemprop="dateModified" datetime="2023-11-28T23:39:07+08:00">2023-11-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>该文只介绍clusterctl的generate命令，源码在cluster-api中。以下分析仅作参考。<br>同时，在<a target="_blank" rel="noopener" href="https://github.com/xichuanliang/yamlv1%E4%B8%AD%E6%8F%90%E5%8F%96%E4%BA%86clusterctl">https://github.com/xichuanliang/yamlv1中提取了clusterctl</a> gengerate的代码用于读取本地template文件和conf文件，初始化template<br>clusterctl generate用于根据给定的template生成对应的yaml，从而创建cluster-api所需的yaml资源，如cluster、machinedeployment、kubeadmcontrolplane等。上述资源供cluster-api生成一个k8s集群。</p>
<ul>
<li><p>clustectl中的命令都是基于cobra框架而生成的</p>
</li>
<li><p>在cobra框架中RunE代表在执行该命令的时候，执行的函数。RunE表示该命令能够返回错误信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generateClusterClusterCmd = &amp;cobra.Command&#123;</span><br><span class="line">	Use:   <span class="string">&quot;cluster NAME&quot;</span>,</span><br><span class="line">	Short: <span class="string">&quot;Generate templates for creating workload clusters&quot;</span>,</span><br><span class="line">	Long: LongDesc(<span class="string">`</span></span><br><span class="line"><span class="string">		Generate templates for creating workload clusters.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		clusterctl ships with a list of known providers; if necessary, edit</span></span><br><span class="line"><span class="string">		$XDG_CONFIG_HOME/cluster-api/clusterctl.yaml to add new provider or to customize existing ones.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		Each provider configuration links to a repository; clusterctl uses this information</span></span><br><span class="line"><span class="string">		to fetch templates when creating a new cluster.`</span>),</span><br><span class="line"></span><br><span class="line">	Example: Examples(<span class="string">`</span></span><br><span class="line"><span class="string">		# Generates a yaml file for creating workload clusters using</span></span><br><span class="line"><span class="string">		# the pre-installed infrastructure and bootstrap providers.</span></span><br><span class="line"><span class="string">		clusterctl generate cluster my-cluster</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args: func(cmd *cobra.Command, args []string) error &#123;</span></span><br><span class="line"><span class="string">		if len(args) != 1 &#123;</span></span><br><span class="line"><span class="string">			return errors.New(&quot;please specify a cluster name&quot;)</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		return nil</span></span><br><span class="line"><span class="string">	&#125;,</span></span><br><span class="line"><span class="string">	RunE: func(cmd *cobra.Command, args []string) error &#123;</span></span><br><span class="line"><span class="string">		return runGenerateClusterTemplate(cmd, args[0])</span></span><br><span class="line"><span class="string">	&#125;,</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>runGenerateClusterTemplate命令用于根据template生成一个yaml</p>
</li>
<li><p>该方法中最重要的便是GetClusterTemplate()方法，用于生成template。其中templateOptions对template做一些template初始化的选项，比如设置负载集群K8s的版本、master节点个数，负载集群的namespace等等。这些参数都将作用于template。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runGenerateClusterTemplate</span><span class="params">(cmd *cobra.Command, name <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	<span class="comment">// 用于生成configClient</span></span><br><span class="line">	c, err := client.New(ctx, cfgFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	templateOptions := client.GetClusterTemplateOptions&#123;</span><br><span class="line">		Kubeconfig:        client.Kubeconfig&#123;Path: gc.kubeconfig, Context: gc.kubeconfigContext&#125;,</span><br><span class="line">		ClusterName:       name,</span><br><span class="line">		TargetNamespace:   gc.targetNamespace,</span><br><span class="line">		KubernetesVersion: gc.kubernetesVersion,</span><br><span class="line">		ListVariablesOnly: gc.listVariables,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cmd.Flags().Changed(<span class="string">&quot;control-plane-machine-count&quot;</span>) &#123;</span><br><span class="line">		templateOptions.ControlPlaneMachineCount = &amp;gc.controlPlaneMachineCount</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> cmd.Flags().Changed(<span class="string">&quot;worker-machine-count&quot;</span>) &#123;</span><br><span class="line">		templateOptions.WorkerMachineCount = &amp;gc.workerMachineCount</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gc.url != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		templateOptions.URLSource = &amp;client.URLSourceOptions&#123;</span><br><span class="line">			URL: gc.url,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gc.configMapNamespace != <span class="string">&quot;&quot;</span> || gc.configMapName != <span class="string">&quot;&quot;</span> || gc.configMapDataKey != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		templateOptions.ConfigMapSource = &amp;client.ConfigMapSourceOptions&#123;</span><br><span class="line">			Namespace: gc.configMapNamespace,</span><br><span class="line">			Name:      gc.configMapName,</span><br><span class="line">			DataKey:   gc.configMapDataKey,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gc.infrastructureProvider != <span class="string">&quot;&quot;</span> || gc.flavor != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		templateOptions.ProviderRepositorySource = &amp;client.ProviderRepositorySourceOptions&#123;</span><br><span class="line">			InfrastructureProvider: gc.infrastructureProvider,</span><br><span class="line">			Flavor:                 gc.flavor,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	template, err := c.GetClusterTemplate(ctx, templateOptions)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> gc.listVariables &#123;</span><br><span class="line">		<span class="keyword">return</span> printVariablesOutput(template, templateOptions)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> printYamlOutput(template, gc.output)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>GetClusterTemplate()根据templateOptions初始化template</p>
</li>
<li><p>在该方法中会生成clusterClient。这是一个函数类型，最重要的是根据options构造了ClusterClientFactoryInput{options.Kubeconfig, options.YamlProcessor}结构体。其中YamlProcessor会对template进行真正的初始化。</p>
</li>
<li><p>该方法中会选择一个template源进行初始化，本文主要讲解使用固定的template文件进行初始化，即通过URL获取template源。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *clusterctlClient)</span></span> GetClusterTemplate(ctx context.Context, options GetClusterTemplateOptions) (Template, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 检查template的来源个数，template可以从provider repository、configMap、URL中获取</span></span><br><span class="line">    <span class="comment">// 如果template来源大于1是无法选择template进行初始化的</span></span><br><span class="line">	numsSource := options.numSources()</span><br><span class="line">	<span class="keyword">if</span> numsSource &gt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;invalid cluster template source: only one template can be used at time&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> numsSource == <span class="number">0</span> &#123;</span><br><span class="line">		options.ProviderRepositorySource = &amp;ProviderRepositorySourceOptions&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成clusterClient</span></span><br><span class="line">	clusterClient, err := c.clusterClientFactory(ClusterClientFactoryInput&#123;options.Kubeconfig, options.YamlProcessor&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对options中的某些字段进行校验，如果没有或不符合规则就返回错误信息</span></span><br><span class="line">	<span class="keyword">if</span> options.TargetNamespace == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := clusterClient.Proxy().CheckClusterAvailable(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;management cluster not available. Cannot auto-discover target namespace. Please specify a target namespace&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		currentNamespace, err := clusterClient.Proxy().CurrentNamespace()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> currentNamespace == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;failed to identify the current namespace. Please specify a target namespace&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		options.TargetNamespace = currentNamespace</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将参数中的某些变量注入进clusterClient的configClient中</span></span><br><span class="line">	<span class="keyword">if</span> err := c.templateOptionsToVariables(options); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 选择一个template源</span></span><br><span class="line">	<span class="keyword">if</span> options.ProviderRepositorySource != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Ensure this command only runs against management clusters with the current Cluster API contract.</span></span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span> This command tolerates also not existing cluster (Kubeconfig.Path==&quot;&quot;) or clusters not yet initialized in order to allow</span></span><br><span class="line">		<span class="comment">// users to dry-run the command and take a look at what the cluster will look like; in both scenarios, it is required</span></span><br><span class="line">		<span class="comment">// to pass provider:version given that auto-discovery can&#x27;t work without a provider inventory installed in a cluster.</span></span><br><span class="line">		<span class="keyword">if</span> options.Kubeconfig.Path != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := clusterClient.ProviderInventory().CheckCAPIContract(ctx, cluster.AllowCAPINotInstalled&#123;&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> c.getTemplateFromRepository(ctx, clusterClient, options)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> options.ConfigMapSource != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c.getTemplateFromConfigMap(ctx, clusterClient, *options.ConfigMapSource, options.TargetNamespace, options.ListVariablesOnly)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 通过URL获取template源</span></span><br><span class="line">	<span class="keyword">if</span> options.URLSource != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c.getTemplateFromURL(ctx, clusterClient, *options.URLSource, options.TargetNamespace, options.ListVariablesOnly)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;unable to read custom template. Please specify a template source&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据template源，将template读取到内存中</p>
</li>
<li><p>最重要的是初始化TemplateInput{}，然后执行repository.NewTemplate，对template进行初始化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *clusterctlClient)</span></span> getTemplateFromURL(ctx context.Context, cluster cluster.Client, source URLSourceOptions, targetNamespace <span class="type">string</span>, listVariablesOnly <span class="type">bool</span>) (Template, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> cluster.Template().GetFromURL(ctx, source.URL, targetNamespace, listVariablesOnly)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *templateClient)</span></span> GetFromURL(ctx context.Context, templateURL, targetNamespace <span class="type">string</span>, skipTemplateProcess <span class="type">bool</span>) (repository.Template, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> templateURL == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;invalid GetFromURL operation: missing templateURL value&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据URL读取template到内存中</span></span><br><span class="line">	content, err := t.getURLContent(ctx, templateURL)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;invalid GetFromURL operation&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化NewTemplate</span></span><br><span class="line">	<span class="keyword">return</span> repository.NewTemplate(repository.TemplateInput&#123;</span><br><span class="line">		RawArtifact:           content, <span class="comment">// 读取的内容</span></span><br><span class="line">		ConfigVariablesClient: t.configClient.Variables(), </span><br><span class="line">		Processor:             t.processor, <span class="comment">// 执行template的初始化</span></span><br><span class="line">		TargetNamespace:       targetNamespace, <span class="comment">// 负载集群的namespace</span></span><br><span class="line">		SkipTemplateProcess:   skipTemplateProcess, <span class="comment">// 是否不使用TemplateProcess，即不使用t.processor对模板进行处理</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没什么特别的，就是读取template</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *templateClient)</span></span> getURLContent(ctx context.Context, templateURL <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> templateURL == <span class="string">&quot;-&quot;</span> &#123;</span><br><span class="line">		b, err := io.ReadAll(os.Stdin)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;failed to read stdin&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rURL, err := url.Parse(templateURL)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;failed to parse %q&quot;</span>, templateURL)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> rURL.Scheme == <span class="string">&quot;https&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> rURL.Host == <span class="string">&quot;github.com&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> t.getGitHubFileContent(ctx, rURL)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> t.getRawURLFileContent(ctx, templateURL)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> rURL.Scheme == <span class="string">&quot;file&quot;</span> || rURL.Scheme == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.getLocalFileContent(rURL)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;unable to read content from %q. Only reading from GitHub and local file system is supported&quot;</span>, templateURL)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *templateClient)</span></span> getLocalFileContent(rURL *url.URL) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	f, err := os.Stat(rURL.Path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;failed to read file %q&quot;</span>, rURL.Path)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> f.IsDir() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;invalid path: file %q is actually a directory&quot;</span>, rURL.Path)</span><br><span class="line">	&#125;</span><br><span class="line">	content, err := os.ReadFile(rURL.Path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;failed to read file %q&quot;</span>, rURL.Path)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> content, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化template</p>
</li>
<li><p>input.Processor.GetVariables()，根据input读取到的content，提取变量到[]string中</p>
</li>
<li><p>input.Processor.GetVariableMap()，根据input读取到的content，将各个变量提取到map中</p>
</li>
<li><p>input.Processor.Process()，对模板进行初始化</p>
</li>
<li><p>utilyaml.ToUnstructured()，将读取到的yaml转化为k8s中的unstructured.Unstructured类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTemplate</span><span class="params">(input TemplateInput)</span></span> (Template, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据input读取到的content，对各个变量提取到[]string中</span></span><br><span class="line">	variables, err := input.Processor.GetVariables(input.RawArtifact)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据input读取到的content，将各个变量提取到map中</span></span><br><span class="line">	variableMap, err := input.Processor.GetVariableMap(input.RawArtifact)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果上文的SkipTemplateProcess为true，则不用提供的process方法对template进行初始化</span></span><br><span class="line">	<span class="keyword">if</span> input.SkipTemplateProcess &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;template&#123;</span><br><span class="line">			variables:       variables,</span><br><span class="line">			variableMap:     variableMap,</span><br><span class="line">			targetNamespace: input.TargetNamespace,</span><br><span class="line">		&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 对模板进行初始化</span></span><br><span class="line">	processedYaml, err := input.Processor.Process(input.RawArtifact, input.ConfigVariablesClient.Get)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将读取到的yaml转化为k8s中的unstructured.Unstructured类型</span></span><br><span class="line">	objs, err := utilyaml.ToUnstructured(processedYaml)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;failed to parse yaml&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> input.TargetNamespace != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// Ensures all the template components are deployed in the target namespace (applies only to namespaced objects)</span></span><br><span class="line">		<span class="comment">// This is required in order to ensure a cluster and all the related objects are in a single namespace, that is a requirement for</span></span><br><span class="line">		<span class="comment">// the clusterctl move operation (and also for many controller reconciliation loops).</span></span><br><span class="line">		objs, err = fixTargetNamespace(objs, input.TargetNamespace)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;failed to set the TargetNamespace in the template&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化template，其中objs中存放的就是即将在K8s中创建的资源</span></span><br><span class="line">	<span class="keyword">return</span> &amp;template&#123;</span><br><span class="line">		variables:       variables,</span><br><span class="line">		variableMap:     variableMap,</span><br><span class="line">		targetNamespace: input.TargetNamespace,</span><br><span class="line">		objs:            objs,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/container/page/2/">2</a><a class="extend next" rel="next" href="/container/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/container/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/container/lib/anime.min.js"></script>
  <script src="/container/lib/velocity/velocity.min.js"></script>
  <script src="/container/lib/velocity/velocity.ui.min.js"></script>

<script src="/container/js/utils.js"></script>

<script src="/container/js/motion.js"></script>


<script src="/container/js/schemes/pisces.js"></script>


<script src="/container/js/next-boot.js"></script>




  















  

  

</body>
</html>
